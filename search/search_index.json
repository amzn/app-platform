{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"App Platform","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The App Platform is a lightweight application framework for state and memory management suitable for Kotlin Multiplatform projects, in particular Android, iOS, JVM, native and Web. It makes the dependency inversion (1) and dependency injection (DI) design patterns first class principles to develop features and support the variety of platforms. The UI layer is entirely decoupled from the business logic, which allows different application targets to change the look and feel.</p> <ol> <li>Dependency inversion means that high-level APIs don\u2019t depend on low-level details and low-level details only import other high-level APIs.</li> </ol> <p>App Platform pushes for code reuse by sharing APIs and implementations, while making it easy to leverage platform strengths and changing app or device specific behavior when needed. The framework helps you to get started writing Kotlin Multiplatform effectively.</p> Web (clickable)AndroidiOSDesktopWeb Recipe App <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>App Platform combines several features as a single framework. While all of them are optional, together they help to implement recommended best practices and design patterns.</p>"},{"location":"#module-structure","title":"Module Structure","text":"<p>The module structure helps to separate APIs from implementations. This prevents leaking implementation details, forces developers to think about strong APIs and reduces build times. Checks for the correct usage of the module structure are implemented in the Gradle plugin.</p>"},{"location":"#dependency-injection","title":"Dependency Injection","text":"<p>App Platform by default provides support for kotlin-inject-anvil and  Metro as dependency injection solution. But these frameworks aren\u2019t enforced and you can  bring your own (1).</p> <ol> <li>In the very first versions of App Platform, we at Amazon used Dagger 2 and Anvil. Later we migrated to kotlin-inject-anvil.</li> </ol>"},{"location":"#scopes","title":"Scopes","text":"<p><code>Scopes</code> are essential in our architecture. They define the boundary our software components operate in. A scope is a space with a well-defined lifecycle that can be created and torn down. App Platform provides hooks to create your own scopes with easy callbacks, integration for dependency injection frameworks and <code>CoroutineScopes</code>.</p>"},{"location":"#presenters","title":"Presenters","text":"<p>Presenters are implemented using Molecule. Writing business and navigation logic using Compose is significantly easier than chaining <code>Flows</code>.</p>"},{"location":"#ui","title":"UI","text":"<p>The UI layer is fully decoupled using Renderers. Compose Multiplatform is fully supported out of the box. For Android there is seamless interop with Android <code>Views</code> (1).</p> <ol> <li>We have a mix of both UI frameworks on Android.</li> </ol>"},{"location":"#testing","title":"Testing","text":"<p>Fakes for unit and device tests are essential and integral part of our architecture. There are many test helpers to setup fakes for core components such as <code>Scopes</code>. We like using Turbine for verifying the reactive behavior of our <code>Presenters</code>. Thanks to Compose Multiplatform, <code>Renderers</code> can be tested in isolation for iOS and Desktop.</p>"},{"location":"#integration","title":"Integration","text":"<p>The Gradle plugin comes with a convenient DSL to take care of many necessary configurations, e.g. it sets up the Compose compiler for Molecule and Compose Multiplatform. It configures KSP and integrates kotlin-inject-anvil or Metro for each platform. It sets the Android namespace and artifact ID when the module structure is enabled.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>App Platform gives you a working Kotlin Multiplatform setup out of the box, with support for Android, iOS, Desktop, and Web (WASM). The fastest way to get started is by using the blueprints/starter project \u2014 a fully functional example app that already uses App Platform and applies everything the platform provides, including the module structure, dependency injection, scopes, presenters, and renderers.</p>"},{"location":"#copy-the-starter-app","title":"Copy the Starter App","text":"<p>To begin a new project:</p> <pre><code>git clone https://github.com/amzn/app-platform.git\ncp -r app-platform/blueprints/starter my-kmp-app\ncd my-kmp-app\n</code></pre> <p>The starter blueprint comes preconfigured with App Platform and is ready to build and run across all supported targets.</p>"},{"location":"#build-and-run","title":"Build and Run","text":"<p>The starter project includes a detailed README with instructions for building and running the app on each platform:</p> <ul> <li>Android</li> <li>iOS</li> <li>Desktop</li> <li>Web (WASM)</li> </ul> <p>Follow the steps in that README to get your app running locally.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#deprecated","title":"Deprecated","text":""},{"location":"changelog/#removed","title":"Removed","text":""},{"location":"changelog/#fixed","title":"Fixed","text":""},{"location":"changelog/#security","title":"Security","text":""},{"location":"changelog/#other-notes-contributions","title":"Other Notes &amp; Contributions","text":""},{"location":"changelog/#008-2025-01-27","title":"0.0.8 - 2025-01-27","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added a recipe for <code>Presenter</code> integration with SwiftUI, see #154.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Kotlin to <code>2.2.21</code>, see #161</li> <li>KSP to <code>2.3.4</code></li> <li>kotlin-inject to <code>0.9.0</code></li> <li>kotlin-inject-anvil to <code>0.1.7</code></li> <li>metro to <code>0.10.1</code></li> <li>Remove testing for KSP1 and use KSP2</li> </ul>"},{"location":"changelog/#other-notes-contributions_1","title":"Other Notes &amp; Contributions","text":"<ul> <li>Special thanks to @rvenable for creating the original Swift APIs that served as the foundation for #154!</li> </ul>"},{"location":"changelog/#007-2025-09-26","title":"0.0.7 - 2025-09-26","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Changed the min SDK from 21 to 23, see #149.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix NPE when removing Android Views from multiple child renderers with the same parent on activity destruction, see #150.</li> </ul>"},{"location":"changelog/#006-2025-09-05","title":"0.0.6 - 2025-09-05","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added support for Metro as dependency injection framework. User can choose between <code>kotlin-inject-anvil</code> and Metro. For more details see the documentation for how to setup and use both dependency injection frameworks with App Platform.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Changed the provided <code>CoroutineScope</code> within <code>ViewRenderer</code> from a custom scope to <code>MainScope()</code>, see #124.</li> <li>Disallow changing the parent View for <code>ViewRenderers</code>. For a different parent view <code>RendererFactory.getRenderer()</code> will now return a new <code>Renderer</code> instead of the cached instance. The cached instance is only returned for the same parent view, see #139.</li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecated <code>diComponent()</code> and introduce <code>kotlinInjectComponent()</code> as replacement, see #106.</li> <li>Deprecated <code>RendererFactory.getChildRendererForParent()</code>. <code>RendererFactory.getRenderer()</code> now provides the same functionality, see #139.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix and stop suppressing NPE when removing Android Views, which lead to an inconsistent state and potential crashes laters, see #136.</li> <li>Cancel the <code>CoroutineScope</code> in <code>ViewRenderer</code> in rare cases where <code>onDetach</code> for the view isn\u2019t triggered. This caused potential leaks, see #140.</li> </ul>"},{"location":"changelog/#005-2025-08-15","title":"0.0.5 - 2025-08-15","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Added support for the new Android-KMP library plugin in App Platform\u2019s Gradle plugin.</li> <li>Added a recipe for how to use the Navigation 3 library with App Platform.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Upgraded Kotlin to <code>2.2.10</code>.</li> </ul>"},{"location":"changelog/#004-2025-07-25","title":"0.0.4 - 2025-07-25","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added a search field to the wiki.</li> <li>Added a blueprint project for App Platform that can be copied to spin up new projects faster, see #63.</li> <li>Added support for back press events in <code>Presenters</code>. The API is similar to the one from Compose Multiplatform and Android Compose. See the documentation in the wiki for more details.</li> <li>Added a recipes application showing solutions to common problems. All solutions have been documented in the wiki.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Upgraded Kotlin to <code>2.2.0</code>.</li> </ul>"},{"location":"changelog/#003-2025-05-28","title":"0.0.3 - 2025-05-28","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Wasm JS is now officially supported and artifacts are published.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Snapshots are now published to the Central Portal Snapshots repository at https://central.sonatype.com/repository/maven-snapshots/.</li> <li>Upgraded Kotlin to <code>2.1.21</code>.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Removed the deprecated <code>onEvent</code> function used in <code>MoleculePresenters</code>. This is no longer needed since Kotlin 2.0.20, see #21.</li> </ul>"},{"location":"changelog/#002-2025-05-02","title":"0.0.2 - 2025-05-02","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Breaking change: Changed the constructor from <code>ComposeAndroidRendererFactory</code> to two factory functions instead. A new API allows you to use this factory without an Android View as parent, see #39.</li> </ul>"},{"location":"changelog/#deprecated_2","title":"Deprecated","text":"<ul> <li>Deprecated the <code>onEvent</code> function used in <code>MoleculePresenters</code>. This is no longer needed since Kotlin 2.0.20, see #21.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Made the <code>ModuleStructureDependencyCheckTask</code> cacheable, see #19.</li> <li>Fixed violations for Gradle\u2019s project isolation feature, see #20.</li> </ul>"},{"location":"changelog/#other-notes","title":"Other Notes","text":"<ul> <li>Updated the sample application with a shared transition animation to highlight how animations can be implemented for <code>Template</code> updates, see #37.</li> </ul>"},{"location":"changelog/#001-2025-04-17","title":"0.0.1 - 2025-04-17","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"di/","title":"DI Framework","text":"<p>Note</p> <p>App Platform provides support for kotlin-inject-anvil and  Metro as dependency injection framework. You can choose which one to use and even mix them if needed. Both frameworks are compile-time injection frameworks and ready for Kotlin Multiplatform  (Metro still runs into issues). They verify correctness of the object graph at build time and avoid crashes at  runtime.</p> <p>Enabling dependency injection is an opt-in feature through the Gradle DSL. The default value is <code>false</code>. <pre><code>appPlatform {\n  enableKotlinInject true\n  enableMetro true\n}\n</code></pre></p> <p>Tip</p> <p>Consider taking a look at the kotlin-inject-anvil documentation or Metro documentation first. App Platform makes heavy use the of  <code>@ContributesBinding</code> and <code>@ContributesTo</code> annotations to decompose and assemble components / object graphs.</p>"},{"location":"di/#kotlin-inject-anvil","title":"kotlin-inject-anvil","text":"<p>Note</p> <p><code>kotlin-inject-anvil</code> is an opt-in feature through the Gradle DSL. The default value is <code>false</code>. <pre><code>appPlatform {\n  enableKotlinInject true\n}\n</code></pre></p>"},{"location":"di/#component","title":"Component","text":"<p>Components are added as a service to the <code>Scope</code> class and can be obtained using the <code>kotlinInjectComponent()</code> extension function:</p> <pre><code>scope.kotlinInjectComponent&lt;AppComponent&gt;()\n</code></pre> <p>In modularized projects, final components are defined in the <code>:app</code> modules, because the object graph has to know about all features of the app. It is strongly recommended to create a component in each platform specific folder to provide platform specific types.</p> AndroidiOSDesktopWasmJs androidMain<pre><code>@SingleIn(AppScope::class)\n@MergeComponent(AppScope::class)\nabstract class AndroidAppComponent(\n  @get:Provides val application: Application,\n  @get:Provides val rootScopeProvider: RootScopeProvider,\n)\n</code></pre> iosMain<pre><code>@SingleIn(AppScope::class)\n@MergeComponent(AppScope::class)\nabstract class IosAppComponent(\n  @get:Provides val uiApplication: UIApplication,\n  @get:Provides val rootScopeProvider: RootScopeProvider,\n)\n</code></pre> desktopMain<pre><code>@SingleIn(AppScope::class)\n@MergeComponent(AppScope::class)\nabstract class DesktopAppComponent(\n  @get:Provides val rootScopeProvider: RootScopeProvider\n)\n</code></pre> wasmJsMain<pre><code>@MergeComponent(AppScope::class)\n@SingleIn(AppScope::class)\nabstract class WasmJsAppComponent(\n  @get:Provides val rootScopeProvider: RootScopeProvider\n)\n</code></pre>"},{"location":"di/#platform-implementations","title":"Platform implementations","text":"<p><code>kotlin-inject-anvil</code> makes it simple to provide platform specific implementations for abstract APIs without needing to use <code>expect / actual</code> declarations or any specific wiring. Since the final components live in the platform specific source folders, all contributions for a platform are automatically picked up. Platform specific implementations can use and inject types from the platform.</p> commonMain<pre><code>interface LocationProvider\n</code></pre> AndroidiOSDesktopWasmJs androidMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass AndroidLocationProvider(\n  val application: Application,\n) : LocationProvider\n</code></pre> iosMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass IosLocationProvider(\n  val uiApplication: UIApplication,\n) : LocationProvider\n</code></pre> desktopMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass DesktopLocationProvider(\n  ...\n) : LocationProvider\n</code></pre> wasmJsMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass WasmLocationProvider(\n  ...\n) : LocationProvider\n</code></pre> <p>Other common code within <code>commonMain</code> can safely inject and use <code>LocationProvider</code>.</p>"},{"location":"di/#injecting-dependencies","title":"Injecting dependencies","text":"<p>It\u2019s recommended to rely on constructor injection as much as possible, because it removes boilerplate and makes testing easier. But it some cases it\u2019s required to get a dependency from a component where constructor injection is not possible, e.g. in a static context or types created by the platform. In this case a contributed component interface with access to the <code>Scope</code> help:</p> androidMain<pre><code>class MainActivityViewModel(application: Application) : AndroidViewModel(application) {\n\n  private val component = (application as RootScopeProvider).rootScope.kotlinInjectComponent&lt;Component&gt;()\n  private val templateProvider = component.templateProviderFactory.createTemplateProvider()\n\n  @ContributesTo(AppScope::class)\n  interface Component {\n    val templateProviderFactory: TemplateProvider.Factory\n  }\n}\n</code></pre> <p>This sample shows an Android <code>ViewModel</code> that doesn\u2019t use constructor injection. Instead, the <code>Scope</code> is retrieved from the <code>Application</code> class and the <code>kotlin-inject-anvil</code> component is found through the <code>kotlinInjectComponent()</code> function.</p> Sample <p>The <code>ViewModel</code> example comes from the sample app. <code>ViewModels</code> can use constructor injection, but this requires more setup. This approach of using a component interface was simpler and faster.</p> <p>Another example where this approach is handy is in <code>NavigationPresenterImpl</code>. This class waits for the user scope to be available and then optionally retrieves the <code>Presenter</code> that is part of the user component. Constructor injection cannot be used, because <code>NavigationPresenterImpl</code> is part of the app scope and cannot inject dependencies from the user scope, which is a child scope of app scope. This would violate dependency inversion rules.</p> <pre><code>@ContributesTo(UserScope::class)\ninterface UserComponent {\n  val userPresenter: UserPagePresenter\n}\n\n@Composable\noverride fun present(input: Unit): BaseModel {\n  val scope = getUserScope()\n  if (scope == null) {\n    // If no user is logged in, then show the logged in screen.\n    val presenter = remember { loginPresenter() }\n    return presenter.present(Unit)\n  }\n\n  // A user is logged in. Use the user component to get an instance of UserPagePresenter, which is only\n  // part of the user scope.\n  val userPresenter = remember(scope) { scope.kotlinInjectComponent&lt;UserComponent&gt;().userPresenter }\n  return userPresenter.present(Unit)\n}\n</code></pre>"},{"location":"di/#default-bindings","title":"Default bindings","text":"<p>App Platform provides a few defaults that can be injected, including a <code>CoroutineScope</code> and <code>CoroutineDispatchers</code>.</p> <pre><code>@Inject\nclass SampleClass(\n  @ForScope(AppScope::class) appScope: CoroutineScope,\n\n  @IoCoroutineDispatcher ioDispatcher: CoroutineDispatcher,\n  @DefaultCoroutineDispatcher defaultDispatcher: CoroutineDispatcher,\n  @MainCoroutineDispatcher mainDispatcher: CoroutineDispatcher,\n)\n</code></pre> <p>CoroutineScope</p> <p>The <code>CoroutineScope</code> uses the IO dispatcher by default. The qualifier <code>@ForScope(AppScope::class)</code> is needed to allow other scopes to have their own <code>CoroutineScope</code>. For example, the sample app provides a <code>CoroutineScope</code> for the user scope, which gets canceled when the user scope gets destroyed. The <code>CoroutineScope</code> for the user scope uses the qualifier `@ForScope(UserScope::class)</p> <pre><code>/**\n * Provides the [CoroutineScopeScoped] for the user scope. This is a single instance for the user\n * scope.\n */\n@Provides\n@SingleIn(UserScope::class)\n@ForScope(UserScope::class)\nfun provideUserScopeCoroutineScopeScoped(\n  @IoCoroutineDispatcher dispatcher: CoroutineDispatcher\n): CoroutineScopeScoped {\n  return CoroutineScopeScoped(dispatcher + SupervisorJob() + CoroutineName(\"UserScope\"))\n}\n\n/**\n * Provides the [CoroutineScope] for the user scope. A new child scope is created every time an\n * instance is injected so that the parent cannot be canceled accidentally.\n */\n@Provides\n@ForScope(UserScope::class)\nfun provideUserCoroutineScope(\n  @ForScope(UserScope::class) userScopeCoroutineScopeScoped: CoroutineScopeScoped\n): CoroutineScope {\n  return userScopeCoroutineScopeScoped.createChild()\n}\n</code></pre> <p>CoroutineDispatcher</p> <p>It\u2019s recommended to inject <code>CoroutineDispatcher</code> through the constructor instead of using <code>Dispatcher.*</code>. This allows to easily swap them within unit tests to remove concurrency and improve stability.</p>"},{"location":"di/#metro","title":"Metro","text":"<p>Note</p> <p>Metro is an opt-in feature through the Gradle DSL. The default value is <code>false</code>. <pre><code>appPlatform {\n  enableMetro true\n}\n</code></pre></p> <p>Bug</p> <p>There are several bugs and issues related to Metro and the integration is considered experimental until these problems are resolved and Metro itself becomes stable. More details are listed in the bugs section. </p>"},{"location":"di/#dependency-graph","title":"Dependency graph","text":"<p>Dependency graphs are added as a service to the <code>Scope</code> class and can be obtained using the <code>metroDependencyGraph()</code>  extension function:</p> <pre><code>scope.metroDependencyGraph&lt;AppGraph&gt;()\n</code></pre> <p>In modularized projects, final graphs are defined in the <code>:app</code> modules, because the object graph has to know about all features of the app. It is strongly recommended to create an object graph in each platform specific folder to provide platform specific types.</p> AndroidiOSDesktopWasmJs androidMain<pre><code>@DependencyGraph(AppScope::class)\ninterface AndroidAppGraph {\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(\n      @Provides application: Application,\n      @Provides rootScopeProvider: RootScopeProvider,\n    ): AndroidAppGraph\n  }\n}\n</code></pre> iosMain<pre><code>@DependencyGraph(AppScope::class)\ninterface IosAppGraph {\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(\n      @Provides uiApplication: UIApplication,\n      @Provides rootScopeProvider: RootScopeProvider,\n    ): IosAppGraph\n  }\n}\n</code></pre> desktopMain<pre><code>@DependencyGraph(AppScope::class)\ninterface DesktopAppGraph {\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides rootScopeProvider: RootScopeProvider): DesktopAppGraph\n  }\n}\n</code></pre> wasmJsMain<pre><code>@DependencyGraph(AppScope::class)\ninterface WasmJsAppGraph {\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides rootScopeProvider: RootScopeProvider): WasmJsAppGraph\n  }\n}\n</code></pre>"},{"location":"di/#platform-implementations_1","title":"Platform implementations","text":"<p>Metro makes it simple to provide platform specific implementations for abstract APIs without needing to use <code>expect / actual</code> declarations or any specific wiring. Since the final object graphs live in the platform  specific source folders, all contributions for a platform are automatically picked up. Platform specific  implementations can use and inject types from the platform.</p> commonMain<pre><code>interface LocationProvider\n</code></pre> AndroidiOSDesktopWasmJs androidMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass AndroidLocationProvider(\n  val application: Application,\n) : LocationProvider\n</code></pre> iosMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass IosLocationProvider(\n  val uiApplication: UIApplication,\n) : LocationProvider\n</code></pre> desktopMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass DesktopLocationProvider(\n  ...\n) : LocationProvider\n</code></pre> wasmJsMain<pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass WasmLocationProvider(\n  ...\n) : LocationProvider\n</code></pre> <p>Other common code within <code>commonMain</code> can safely inject and use <code>LocationProvider</code>.</p>"},{"location":"di/#injecting-dependencies_1","title":"Injecting dependencies","text":"<p>It\u2019s recommended to rely on constructor injection as much as possible, because it removes boilerplate and makes testing easier. But it some cases it\u2019s required to get a dependency from an object graph where constructor injection is not possible, e.g. in a static context or types created by the platform. In this case a contributed object graph interface with access to the <code>Scope</code> help:</p> androidMain<pre><code>class MainActivityViewModel(application: Application) : AndroidViewModel(application) {\n\n  private val graph = (application as RootScopeProvider).rootScope.metroDependencyGraph&lt;Graph&gt;()\n  private val templateProvider = graph.templateProviderFactory.createTemplateProvider()\n\n  @ContributesTo(AppScope::class)\n  interface Graph {\n    val templateProviderFactory: TemplateProvider.Factory\n  }\n}\n</code></pre> <p>This sample shows an Android <code>ViewModel</code> that doesn\u2019t use constructor injection. Instead, the <code>Scope</code> is retrieved from the <code>Application</code> class and the Metro object graph is found through the <code>metroDependencyGraph()</code> function.</p> Sample <p>The <code>ViewModel</code> example comes from the sample app. <code>ViewModels</code> can use constructor injection, but this requires more setup. This approach of using a graph interface was simpler and faster.</p> <p>Another example where this approach is handy is in <code>NavigationPresenterImpl</code>. This class waits for the user scope to be available and then optionally retrieves the <code>Presenter</code> that is part of the user graph. Constructor injection cannot be used, because <code>NavigationPresenterImpl</code> is part of the app scope and cannot inject dependencies from the user scope, which is a child scope of app scope. This would violate dependency inversion rules.</p> <pre><code>@ContributesTo(UserScope::class)\ninterface UserGraph {\n  val userPresenter: UserPagePresenter\n}\n\n@Composable\noverride fun present(input: Unit): BaseModel {\n  val scope = getUserScope()\n  if (scope == null) {\n    // If no user is logged in, then show the logged in screen.\n    val presenter = remember { loginPresenter() }\n    return presenter.present(Unit)\n  }\n\n  // A user is logged in. Use the user graph to get an instance of UserPagePresenter, which is only\n  // part of the user scope.\n  val userPresenter = remember(scope) { scope.metroDependencyGraph&lt;UserGraph&gt;().userPresenter }\n  return userPresenter.present(Unit)\n}\n</code></pre>"},{"location":"di/#default-bindings_1","title":"Default bindings","text":"<p>App Platform provides a few defaults that can be injected, including a <code>CoroutineScope</code> and <code>CoroutineDispatchers</code>.</p> <pre><code>@Inject\nclass SampleClass(\n  @ForScope(AppScope::class) appScope: CoroutineScope,\n\n  @IoCoroutineDispatcher ioDispatcher: CoroutineDispatcher,\n  @DefaultCoroutineDispatcher defaultDispatcher: CoroutineDispatcher,\n  @MainCoroutineDispatcher mainDispatcher: CoroutineDispatcher,\n)\n</code></pre> <p>CoroutineScope</p> <p>The <code>CoroutineScope</code> uses the IO dispatcher by default. The qualifier <code>@ForScope(AppScope::class)</code> is needed to allow other scopes to have their own <code>CoroutineScope</code>. For example, the sample app provides a <code>CoroutineScope</code> for the user scope, which gets canceled when the user scope gets destroyed. The <code>CoroutineScope</code> for the user scope uses the qualifier `@ForScope(UserScope::class)</p> <pre><code>/**\n * Provides the [CoroutineScopeScoped] for the user scope. This is a single instance for the user\n * scope.\n */\n@Provides\n@SingleIn(UserScope::class)\n@ForScope(UserScope::class)\nfun provideUserScopeCoroutineScopeScoped(\n  @IoCoroutineDispatcher dispatcher: CoroutineDispatcher\n): CoroutineScopeScoped {\n  return CoroutineScopeScoped(dispatcher + SupervisorJob() + CoroutineName(\"UserScope\"))\n}\n\n/**\n * Provides the [CoroutineScope] for the user scope. A new child scope is created every time an\n * instance is injected so that the parent cannot be canceled accidentally.\n */\n@Provides\n@ForScope(UserScope::class)\nfun provideUserCoroutineScope(\n  @ForScope(UserScope::class) userScopeCoroutineScopeScoped: CoroutineScopeScoped\n): CoroutineScope {\n  return userScopeCoroutineScopeScoped.createChild()\n}\n</code></pre> <p>CoroutineDispatcher</p> <p>It\u2019s recommended to inject <code>CoroutineDispatcher</code> through the constructor instead of using <code>Dispatcher.*</code>. This allows to easily swap them within unit tests to remove concurrency and improve stability.</p>"},{"location":"di/#contriubtesscoped","title":"<code>@ContriubtesScoped</code>","text":"<p>Warning</p> <p>This is different between <code>kotlin-inject-anvil</code> and Metro. In <code>kotlin-inject-anvil</code> we repurpose the  <code>@ContributesBinding</code> annotation to make it understand the semantics for the <code>Scoped</code> interface and generate custom code using a custom code generator. Metro doesn\u2019t support this kind of integration and therefore we had to  introduce <code>@ContributesScoped</code> for a similar usage.</p> <p>The <code>Scoped</code> interface is used to notify implementations when a <code>Scope</code> gets created and destroyed. </p> <p><pre><code>class AndroidLocationProvider : LocationProvider, Scoped {\n\n  override fun onEnterScope(scope: Scope) {\n    ...\n  }\n\n  override fun onExitScope() {\n    ...\n  }\n}\n</code></pre> The implementation class <code>AndroidLocationProvider</code> needs to be bound to the super type <code>LocationProvider</code> and use multi-bindings for the <code>Scoped</code> interface. This is a lot of boilerplate to write that be auto-generated using <code>@ContributesScoped</code> instead. When using <code>@ContributesScoped</code>, all bindings are generated and <code>@ContributesBinding</code> doesn\u2019t need to be added. A typical implementation looks like this:</p> <pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass AndroidLocationProvider : LocationProvider, Scoped\n</code></pre> <p>See the documentation for <code>Scoped</code> for more details.</p>"},{"location":"di/#bugs","title":"Bugs","text":"<p>Metro is in an early stage and there are several bugs blocking a full roll out.</p>"},{"location":"di/#no-full-kmp-support","title":"No full KMP support","text":"<p>Metro is ready to support KMP, but targets other than JVM/Android fail to merge types contributed with  <code>@ContributesTo</code> and <code>@ContributesBinding</code>. App Platform makes heavy use of them. This is called out in the  Metro documentation. There is a chance this will be fixed in Kotlin 2.3.</p> <p>There is one issue in the repo right now where the compiler appears to have a bug with generated FIR declarations where it doesn\u2019t deserialize them correctly on non-JVM targets. Waiting for feedback from JB.</p>"},{"location":"di/#incremental-compilation-issues","title":"Incremental compilation issues","text":"<p>While testing Metro in App Platform, we encountered incremental compilation issues that impacted merging components and generated wrong code. This ticket is metro/997.</p> <p>Other IC issues are reported under KT-75865.</p>"},{"location":"di/#missing-integrations","title":"Missing integrations","text":"<p>Almost all App Platform specific custom extensions for <code>kotlin-inject-anvil</code> were migrated to Metro, including <code>@ContributesRenderer</code> and <code>@ContributesRobot</code>. However the integration for <code>@ContributesRealImpl</code> and  <code>@ContributesMockImpl</code> is missing and still needs to be ported. </p>"},{"location":"di/#migration","title":"Migration","text":"<p>Metro and <code>kotlin-inject-anvil</code> are conceptionally very similar. A migration is mostly mechanical. Errors will be  reported at compile time and not runtime. </p> <p>Steps could like this. PR/129 highlights this migration for the  <code>:sample</code> application. </p> <ul> <li>It\u2019s strongly recommended to use the latest Kotlin and Metro version. Metro is a compiler plugin and tied to the compiler to a certain degree.</li> <li>Enable Metro in the Gradle DSL: <pre><code>appPlatform {\n    enableMetro true\n}\n</code></pre></li> <li>Change kotlin-inject specific imports to Metro: <pre><code>me.tatarka.inject.annotations.IntoSet -&gt; dev.zacsweers.metro.IntoSet\nme.tatarka.inject.annotations.Provides -&gt; dev.zacsweers.metro.Provides\nsoftware.amazon.lastmile.kotlin.inject.anvil.AppScope -&gt; dev.zacsweers.metro.AppScope\nsoftware.amazon.lastmile.kotlin.inject.anvil.ContributesTo -&gt; dev.zacsweers.metro.ContributesTo\nsoftware.amazon.lastmile.kotlin.inject.anvil.ForScope -&gt; dev.zacsweers.metro.ForScope\nsoftware.amazon.lastmile.kotlin.inject.anvil.SingleIn -&gt; dev.zacsweers.metro.SingleIn\n</code></pre></li> <li>Update the final kotlin-inject components to Metro. The Metro docs explain the API very well. E.g. this component had to adopt a factory: <pre><code>// Old:\n@Component\n@MergeComponent(AppScope::class)\n@SingleIn(AppScope::class)\nabstract class DesktopAppComponent(@get:Provides val rootScopeProvider: RootScopeProvider) :\n  DesktopAppComponentMerged\n\n// New:\n@DependencyGraph(AppScope::class)\ninterface DesktopAppComponent {\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides rootScopeProvider: RootScopeProvider): DesktopAppComponent\n  }\n}\n</code></pre></li> <li>Change usages of <code>addKotlinInjectComponent()</code> to <code>addMetroDependencyGraph()</code> and usages of <code>kotlinInjectComponent()</code> to <code>metroDependencyGraph()</code>.</li> </ul>"},{"location":"di/#kotlin-inject-anvil-or-metro","title":"<code>kotlin-inject-anvil</code> or Metro","text":"<p>Given the issues highlighted with Metro, it is strongly advised to use <code>kotlin-inject-anvil</code> for  production and Metro only for experiments.  </p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-can-i-incrementally-adopt-app-platform","title":"How can I incrementally adopt App Platform?","text":"<p>App Platform offers many recommendations and best practices and hardly enforces any principles, e.g. it\u2019s possible to adopt the concept of the module structure without the <code>Scope</code> class or <code>Presenters</code>. <code>Presenters</code> can be used without Compose UI. This and the fact that App Platform is extensible allows for an incremental adoption. Apps can leverage the concepts and the framework without migrating all code at once.</p> <p>For example, instead of going all in on the unidirectional dataflow, Android apps can start adopting <code>Presenters</code> and <code>Renderers</code> on an Activity by Activity or Fragment by Fragment basis. Our Android app initially used Dagger 2 and Anvil as dependency injection framework and made it interop with <code>kotlin-inject-anvil</code> before switching fully.</p>"},{"location":"faq/#can-i-use-dagger-2-or-any-other-di-framework","title":"Can I use Dagger 2 or any other DI framework?","text":"<p>It depends, but likely yes. We\u2019ve chosen kotlin-inject-anvil because it supports Kotlin Multiplatform and verifies the dependency graph at compile time.</p> <p>App Platform provides support for Metro out of the box, but there are still rough edges around the KMP support. Long term we may consider moving App Platform to Metro alone.</p> <p>Dagger 2 is more challenging, because it only supports Android and JVM application. That said, App Platform started on Android we used to use Dagger 2. We bridged the Dagger 2 components with the <code>kotlin-inject-anvil</code> components for interop and this served us well for a long time until we fully migrated to <code>kotlin-inject-anvil</code>.</p>"},{"location":"faq/#how-does-app-platform-compare-to-circuit","title":"How does App Platform compare to Circuit?","text":"<p>Circuit shares certain aspects with App Platform in regards to implementing the unidirectional dataflow, e.g. presenters and decoupling UI. How <code>Screens</code> with Circuit work vs how App Platform relies on composing presenters and renderers is different.</p> <p>App Platform goes further and has feature that Circuit doesn\u2019t provide, e.g. the module structure, the strong emphasis on fakes and robots.</p> <p>At Amazon we built App Platform months before Circuit was released in 2022 and at this point there was no reason for us to migrate off of App Platform and to Circuit.</p> <p>Help needed</p> <p>Help from the community for a more in-depth comparison is needed.</p>"},{"location":"faq/#is-app-platform-used-in-production-by-amazon","title":"Is App Platform used in production by Amazon?","text":"<p>App Platform was developed within the Amazon Delivery organization and is used to share code between several applications and platforms. Public products include the in-vehicle delivery app, Amazon Flex for Android and iOS and the Linux based Vision-Assisted Package Retrieval.</p>"},{"location":"module-structure/","title":"Module Structure","text":"<p>Note</p> <p>Using the module structure is an opt-in feature through the Gradle DSL. The default value is <code>false</code> and this feature has to be enabled for each module. <pre><code>appPlatform {\n  enableModuleStructure true\n}\n</code></pre></p> <p>Tip</p> <p><code>:impl</code> modules are usually imported by the final <code>:app</code> modules. This also applies to App Platform itself. This Gradle option imports all necessary <code>:impl</code> modules for enabled features. <pre><code>appPlatform {\n  addImplModuleDependencies true\n}\n</code></pre></p> <p>Sample</p> <p>App Platform itself and the sample app use the module structure to separate APIs from implementations. The sample app highlights how we structure code and make use of the various module types.</p>"},{"location":"module-structure/#dependency-inversion","title":"Dependency inversion","text":"<p>Dependency inversion means that high-level APIs don\u2019t depend on low-level details and low-level details only import other high-level APIs. It significantly reduces coupling between components. Dependency inversion can be implemented on different levels, e.g. in code and in the module structure.</p>"},{"location":"module-structure/#kotlin-code","title":"Kotlin code","text":"<p>Dependency inversion implemented in Kotlin code refers to having abstractions in place instead of relying on concrete implementations. Imagine this example:</p> <pre><code>class AccountProvider(\n  private val database: SqliteDatabase,\n  ...\n) {\n  val currentAccount: StateFlow&lt;Account&gt; = ...\n\n  fun updateCurrentAccount(account: Account) {\n    ...\n  }\n}\n\nclass ChangeAccountHandler(\n  private val accountProvider: AccountProvider\n) {\n\n  private fun onAccountChanged(account: Account) {\n    accountProvider.updateCurrentAccount(account)\n    ...\n  }\n}\n</code></pre> <p><code>ChangeAccountHandler</code> has a strong dependency on <code>AccountProvider</code>. This is problematic in multiple ways. Evolving <code>AccountProvider</code> is challenging, because implementation details are easily leaked and become part of the public API. Every dependency from <code>AccountProvider</code> is exposed to consumers, e.g. <code>ChangeAccountHandler</code> knows that <code>AccountProvider</code> uses Sqlite for its implementation, a detail which should be hidden and makes dependency graphs unnecessarily large. <code>ChangeAccountHandler</code> is hard to test. One has to spin up a Sqlite database in a unit test environment in order to instantiate <code>AccountProvider</code> and pass it as argument to <code>ChangeAccountHandler</code>.</p> <p>A much better approach is introducing abstract APIs:</p> <pre><code>interface AccountProvider {\n  val currentAccount: StateFlow&lt;Account&gt;\n\n  fun updateCurrentAccount(account: Account)\n}\n\nclass SqliteAccountProvider(\n  private val database: SqliteDatabase\n  ...\n) : AccountProvider {\n\n  @VisibleForTesting\n  val allAccounts: List&lt;Account&gt; = ...\n\n  ...\n}\n</code></pre> <p>The interface <code>AccountProvider</code> solves the mentioned shortcomings. <code>SqliteAccountProvider</code> can change and for example expose more fields (<code>allAccounts</code> in this sample) for verifications in unit tests without anyone knowing as the interface doesn\u2019t need to be updated. Sqlite is a pure implementation detail and no consumer of <code>AccountProvider</code> has to know about it. This allows us to easily swap the implementation for a fake <code>AccountProvider</code> together with fake data in a unit test for <code>ChangeAccountHandler</code>.</p> <p>Breaking the dependency serves an additional purpose especially in Kotlin Multiplatform when implementations have platform dependencies:</p> <pre><code>// commonMain\ninterface SqlDriver\n\n// androidMain\nclass AndroidSqlDriver(context: Context) : SqlDriver\n\n// iosMain\nclass NativeSqlDriver() : SqlDriver\n</code></pre> <p>Notice how the Android implementation has a strong dependency on the Android runtime through the <code>Context</code> class. Relying on interfaces / abstract classes together with dependency injection is the preferred way (1) over <code>expect / actual</code> functions to implement dependency inversion as this approach allows platform specific changes.</p> <ol> <li>When you use a DI framework, you inject all of the dependencies through this framework. The same logic applies to handling platform dependencies. We recommend continuing to use DI if you already have it in your project, rather than using the expected and actual functions manually. This way, you can avoid mixing two different ways of injecting dependencies.</li> </ol>"},{"location":"module-structure/#gradle-modules","title":"Gradle modules","text":"<p>The App Platform separates APIs from implementations by splitting the code in separate Gradle modules. The same recommendation applies not only to other core libraries but also feature code due to the many benefits such as smaller dependency graphs, lower coupling and a simple mechanism to replace dependencies with fakes.</p> <p>Imagine having two implementations of the shared interface <code>LocationProvider</code> for two applications Delivery App and Navigation App:</p> <pre><code>interface LocationProvider {\n  val location: StateFlow&lt;Location&gt;\n}\n\nclass DeliveryAppLocationProvider(\n  private val dataLayer: DeliveryAppDataLayer,\n  ...\n) : LocationProvider {..}\n\nclass NavigationAppLocationProvider(\n  private val application: NavigationApplication,\n  ...\n) : LocationProvider {..}\n</code></pre> <p>If both classes live in the same module, then the shared Gradle module must depend on modules belonging to Delivery and Navigation App at the same time. This is not ideal, because then the Delivery App would automatically depend on code from the Navigation App and the Navigation App on Delivery App code through a transitive dependency as highlighted in the diagram below.</p> <pre><code>%%{init: {'themeCSS': '.label { font-family: monospace; }'}}%%\ngraph TD\n  delivery-platform[\"`:delivery-platform`\"]\n  navigation-platform[\"`:navigation-platform`\"]\n  location[\"`**:location**\n  *DeliveryAppLocationProvider*\n  *NavigationAppLocationProvider*`\"]\n  delivery-app[\"`:delivery-app`\"]\n  navigation-app[\"`:navigation-app`\"]\n\n  delivery-platform --&gt; location\n  navigation-platform --&gt; location\n  location --&gt; delivery-app\n  location --&gt; navigation-app</code></pre> <p>To avoid the issue of the transitive dependencies, concrete implementation classes <code>DeliveryAppLocationProvider</code> and <code>NavigationAppLocationProvider</code> could be moved into the final respective application packages <code>:delivery-app</code> and <code>:navigation-app</code>.</p> <pre><code>%%{init: {'themeCSS': '.label { font-family: monospace; }'}}%%\ngraph TD\n  delivery-platform[\"`:delivery-platform`\"]\n  location[\"`:location`\"]\n  navigation-platform[\"`:navigation-platform`\"]\n  delivery-app[\"`**:delivery-app**\n  *DeliveryAppLocationProvider*`\"]\n  navigation-app[\"`**:navigation-app**\n  *NavigationAppLocationProvider*`\"]\n\n  delivery-platform --&gt; delivery-app\n  navigation-platform --&gt; navigation-app\n  location --&gt; delivery-app\n  location --&gt; navigation-app</code></pre> <p>However, this would be a bad approach from a modularization standpoint. The app modules would become larger and larger over time and the many classes within it would have a low cohesion level. Build times get longer roughly linear to the size of the module, because individual build steps such as Kotlin compilation can\u2019t be parallelized.</p> <p>Instead, a similar approach to dependency inversion in Kotlin code is applied to modules. The shared package can be split into a public API and implementation sub-module:</p> <pre><code>%%{init: {'themeCSS': '.label { font-family: monospace; }'}}%%\ngraph TD\n  delivery-platform[\"`:delivery-platform`\"]\n  location-public[\"`:location:public`\"]\n  navigation-platform[\"`:navigation-platform`\"]\n  location-impl-delivery[\"`**:location:impl-delivery**\n  *DeliveryAppLocationProvider*`\"]\n  location-impl-navigation[\"`**:location:impl-navigation**\n  *NavigationAppLocationProvider*`\"]\n  delivery-app[\"`:delivery-app`\"]\n  navigation-app[\"`:navigation-app`\"]\n\n  delivery-platform --&gt; location-impl-delivery\n  navigation-platform --&gt; location-impl-navigation\n  location-public --&gt; location-impl-delivery\n  location-public --&gt; location-impl-navigation\n  location-impl-delivery --&gt; delivery-app\n  location-impl-navigation --&gt; navigation-app</code></pre> <p>By cleanly separating shared code in <code>:public</code> modules from implementations in <code>:impl</code> modules we break dependencies in our build graph. <code>DeliveryAppLocationProvider</code> and <code>NavigationAppLocationProvider</code> provide a separate implementation for each application target of the shared API, have dependencies on each individual platform and yet don\u2019t leak any implementation details nor platform APIs.</p>"},{"location":"module-structure/#module-rules","title":"Module rules","text":"<p>In order to follow the dependency inversion principle correctly the most important rule in this module structure is that no other module but the final application module is allowed to depend on <code>:impl</code> modules. <code>:public</code> modules on the other hand are widely shared and can be imported by any other module.</p> <p></p> <p>A library always comes with a single <code>:public</code> module for shared code. There can be zero, one or more <code>:impl</code> modules, e.g. when dependency inversion isn\u2019t needed, then the <code>:impl</code> module is redundant. When the implementation can be shared between all apps, then only a single <code>:impl</code> module is needed. When there are multiple different implementations for different applications, then multiple <code>:impl</code> modules are required like in the example above. To make code easier to discover, it\u2019s recommended to put all Gradle modules into the same sub module.</p> <p>This module structure reduces coupling between libraries and increases cohesion within modules, which are two desired attributes in a modularized codebase. <code>:impl</code> modules can change and be modified without impacting any other library. Our build dependency graph stays flat and all <code>:impl</code> modules can be compiled and assembled in parallel.</p> <p>The <code>:public / :impl</code> module split is recommended whenever dependency inversion is needed for code, because of all the benefits mentioned above. The split becomes more natural over time and the benefit increases. Rare exceptions are when dependency inversion isn\u2019t applied such as for sharing utilities like extension functions, UI components or test helpers.</p>"},{"location":"module-structure/#module-types","title":"Module types","text":"<p>Beyond <code>:public</code> and <code>:impl</code> modules, there are further optional module types:</p> <p></p>"},{"location":"module-structure/#public","title":"<code>:public</code>","text":"<p><code>:public</code> modules contain the code that should be shared and reused by other modules and libraries. APIs (interfaces) usually live in <code>:public</code> modules, but also code where dependency inversion isn\u2019t applied such as static utilities, extension functions and UI components.</p>"},{"location":"module-structure/#impl","title":"<code>:impl</code>","text":"<p><code>:impl</code> modules contain the concrete implementations of the API from <code>:public</code> modules. A library can have zero or more <code>:impl</code> modules. If a library contains multiple <code>:impl</code> modules, then they\u2019re suffixed with a name, e.g. <code>:login:impl-amazon</code> and <code>:login:impl-google</code>.</p>"},{"location":"module-structure/#internal","title":"<code>:internal</code>","text":"<p><code>:internal</code> modules are used when code should be shared between multiple <code>:impl</code> modules of the same library, but the code should not be exposed through the <code>:public</code> module. This code is internal to this library.</p>"},{"location":"module-structure/#testing","title":"<code>:testing</code>","text":"<p><code>:testing</code> modules provide a mechanism to share utilities or fake implementations for tests with other libraries. <code>:testing</code> modules are allowed to be imported as test dependency by any other module type and are never added to the runtime classpath. Even its own <code>:public</code> module can reuse the code from the <code>:testing</code> module for its tests.</p>"},{"location":"module-structure/#robots","title":"<code>:robots</code>","text":"<p><code>:*-robots</code> modules help implementing the robot pattern for UI tests and make them shareable. Robots must know about concrete implementations, therefore they usually depend on an <code>:impl</code> module, but don\u2019t expose this <code>:impl</code> module on the compile classpath. <code>:robot</code> modules are only imported and reused for UI tests and are never added as dependency to the runtime classpath of a module similar to <code>:testing</code> modules.</p>"},{"location":"module-structure/#app","title":"<code>:app</code>","text":"<p><code>:app</code> modules refer to the final application, where all feature implementations are imported and assembled as a single binary. Therefore, <code>:app</code> modules are allowed to depend on <code>:impl</code> modules of all imported libraries and features.</p>"},{"location":"module-structure/#example","title":"Example","text":"<p>A more complex dependency graph could look like this:</p> <p></p> <p>This example highlights many of the more frequently used dependencies. Notice that the impl modules <code>:location:impl-delivery</code> and <code>:location:impl-navigation</code> both depend on the internal module <code>:location:internal</code> to share some implementations, but non-shared code lives in each <code>:impl</code> module. The <code>:impl</code> modules import application specific code <code>:delivery-app-platform:public</code> and <code>:navigation-app-platform:public</code> safely without leaking the code to the wrong app. Further, <code>:location:impl-navigation</code> imports and uses <code>:navigation:public</code>, but neither the other impl module <code>:location:impl-delivery</code> nor its public module <code>:location:public</code> need to know about this dependency or depend on it.</p> <p>The second library <code>:navigation:public</code>, which imports <code>:location:public</code>, reuses testing module <code>:location:testing</code> for its unit tests. This saves boilerplate to setup fake implementations of the shared APIs from <code>:location:public</code> and discourages using mocking frameworks.</p> <p>The app <code>:navigation-app</code> imports its specific impl module <code>:location:impl-navigation</code>. It also reuses the robots from the <code>:location:impl-navigation-robots</code> module for its UI tests, further reducing strong dependencies on concrete implementations and favoring reusability.</p>"},{"location":"module-structure/#gradle-setup","title":"Gradle setup","text":"<p>Using the module structure is an opt-in feature through the Gradle DSL. The default value is <code>false</code> and this feature has to be enabled for each module.</p> <pre><code>appPlatform {\n  enableModuleStructure true\n}\n</code></pre> <p>With this setting enabled, several checks and features are enabled:</p> <ul> <li>App Platform ensures that the Gradle module follows the naming convention, e.g. it\u2019s named <code>:public</code> or <code>:impl</code>.</li> <li>Default dependencies are added, e.g. an <code>:impl</code> module imports its <code>:public</code> module by default, or <code>:impl-robots</code> imports its <code>:impl</code> module by default.</li> <li>An Android namespace is set automatically if it hasn\u2019t been configured yet.</li> <li>A Gradle task <code>:checkModuleStructureDependencies</code> is registered, which verifies that module structure dependency rules are followed. The <code>:check</code> Gradle task automatically depends on <code>:checkModuleStructureDependencies</code>.</li> <li>A consistent API for an <code>Project.artifactId</code> is available, e.g. for <code>:my-module:public</code> it would return <code>my-module-public</code>.</li> </ul> Sample <p>The sample application doesn\u2019t set the Android namespace anywhere. Instead, it relies on the default from App Platform, e.g. the <code>:sample:templates:impl</code> module uses this generated namespace for its <code>R</code> class:</p> <pre><code>software.amazon.app.platform.sample.templates.impl.R\n</code></pre> <p>App Platform uses the <code>Project.artifactId()</code> API for its own modules. Publishing using the Gradle Maven Publish Plugin is configured here.</p> <pre><code>private fun mavenPublishing(project: Project) {\n  plugins.apply(Plugins.MAVEN_PUBLISH)\n\n  project.extensions\n    .getByType(MavenPublishBaseExtension::class.java)\n    .coordinates(artifactId = project.artifactId())\n}\n</code></pre>"},{"location":"presenter/","title":"Presenter","text":"<p>Note</p> <p>While App Platform has a generic <code>Presenter</code> interface to remove coupling, we strongly recommend using <code>MoleculePresenter</code> for implementations. <code>MoleculePresenters</code> are an opt-in feature through the Gradle DSL. The default value is <code>false</code>.</p> <pre><code>appPlatform {\n  enableMoleculePresenters true\n}\n</code></pre>"},{"location":"presenter/#unidirectional-dataflow","title":"Unidirectional dataflow","text":"<p>App Platform implements the unidirectional dataflow pattern to decouple business logic from UI rendering. Not only does this allow for better testing of business logic and provides clear boundaries, but individual apps can also share more code and change the look and feel when needed.</p>"},{"location":"presenter/#moleculepresenter","title":"<code>MoleculePresenter</code>","text":"<p>In the unidirectional dataflow pattern events and state only travel into one direction through a single stream. State is produced by <code>Presenters</code> and can be observed through a reactive stream:</p> <pre><code>interface Presenter&lt;ModelT : BaseModel&gt; {\n  val model: StateFlow&lt;ModelT&gt;\n}\n</code></pre> <p><code>Presenters</code> can be implemented in many ways as long as they can be converted to this interface. App Platform provides and recommends the implementation using Molecule since it provides many advantages. Molecule is a library that turns a <code>@Composable</code> function into a <code>StateFlow</code>. It leverages the core of Compose without bringing in Compose UI as dependency. The primary use case of Compose is handling, creating and modifying tree-like data structures, which is a natural fit for UI frameworks. Molecule reuses Compose to handle state management and state transitions to implement business logic in the form of <code>@Composable</code> functions with all the benefits that Compose provides.</p> <p>The MoleculePresenter interface looks like this:</p> <pre><code>interface MoleculePresenter&lt;InputT : Any, ModelT : BaseModel&gt; {\n  @Composable\n  fun present(input: InputT): ModelT\n}\n</code></pre> <p><code>Models</code> represent the state of a <code>Presenter</code>. Usually, they\u2019re implemented as immutable, inner data classes of the <code>Presenter</code>. Using sealed hierarchies is a good practice to allow to differentiate between different states:</p> <pre><code>interface LoginPresenter : MoleculePresenter&lt;Model&gt; {\n  sealed interface Model : BaseModel {\n    data object LoggedOut : Model\n\n    data class LoggedIn(\n      val user: User,\n    ) : Model\n  }\n}\n</code></pre> <p>Notice that it\u2019s recommended even for <code>Presenters</code> to follow the dependency inversion principle. <code>LoginPresenter</code> is an interface and there can be multiple implementations.</p> Sample <p>The sample application follows the same principle of dependency inversion. E.g. the API of the <code>LoginPresenter</code> is part of the <code>:public</code> module, while the implementation <code>LoginPresenterImpl</code> lives in the <code>:impl</code> module. This abstraction is used in tests, where <code>FakeLoginPresenter</code> simplifies the test setup of classes relying on <code>LoginPresenter</code>.</p> <p>Observers of the state of a <code>Presenter</code>, such as the UI layer, communicate back to the <code>Presenter</code> through events. Events are sent through a lambda in the <code>Model</code>, which the <code>Presenter</code> must provide:</p> <pre><code>interface LoginPresenter : MoleculePresenter&lt;Unit, Model&gt; {\n\n  sealed interface Event {\n    data object Logout : Event\n\n    data class ChangeName(\n      val newName: String,\n    ) : Event\n  }\n\n  sealed interface Model : BaseModel {\n    data object LoggedOut : Model\n\n    data class LoggedIn(\n      val user: User,\n      val onEvent: (Event) -&gt; Unit,\n    ) : Model\n  }\n}\n</code></pre> <p>A concrete implementation of <code>LoginPresenter</code> could look like this:</p> <pre><code>@Inject\n@ContributesBinding(AppScope::class)\nclass AmazonLoginPresenter : LoginPresenter {\n  @Composable\n  fun present(input: Unit): Model {\n    ..\n    return if (user != null) {\n      LoggedIn(user = user) { event -&gt;\n        when (event) {\n          is Logout -&gt; ..\n          is ChangeName -&gt; ..\n        }\n      }\n    } else {\n      LoggedOut\n    }\n  }\n}\n</code></pre> <p>Note</p> <p><code>MoleculePresenters</code> are never singletons. While they use <code>kotlin-inject-anvil</code> or Metro for constructor injection and automatically bind the concrete implementation to an API using <code>@ContributesBinding</code>, they don\u2019t use the <code>@SingleIn</code> annotation. <code>MoleculePresenters</code> manage their state in the <code>@Composable</code> function with the Compose runtime. Therefore, it\u2019s strongly discouraged to have any class properties.</p>"},{"location":"presenter/#model-driven-navigation","title":"Model driven navigation","text":"<p><code>Presenters</code> are composable, meaning that one presenter could combine N other presenters into a single stream of model objects. With that concept in mind we can decompose large presenters into multiple smaller ones. Not only do they become easier to change, maintain and test, but we can also share and reuse presenters between multiple screens if needed. Presenters form a tree with nested presenters. They\u2019re unaware of their parent and communicate upwards only through their <code>Model</code>.</p> <pre><code>class OnboardingPresenterImpl(\n  // Make presenters lazy to only instantiate them when they're actually needed.\n  private val lazyLoginPresenter: () -&gt; LoginPresenter,\n  private val lazyRegistrationPresenter: () -&gt; RegistrationPresenter,\n) : OnboardingPresenter {\n\n  @Composable\n  fun present(input: Unit): BaseModel {\n    ...\n    return if (mustRegister) {\n      // Remember the presenter to avoid creating a new one during each\n      // composition (in other words when computing a new model).\n      val registrationPresenter = remember { lazyRegistrationPresenter() }\n      registrationPresenter.present(Unit)\n    } else {\n      val loginPresenter = remember { lazyLoginPresenter() }\n      loginPresenter.present(Unit)\n    }\n  }\n}\n</code></pre> <p>Notice how the parent presenter calls the <code>@Composable</code> <code>present()</code> function from the child presenters like a regular function to compute their model and return it.</p> Sample <p><code>NavigationPresenterImpl</code> is another example that highlights this principle.</p> <p><code>UserPagePresenterImpl</code> goes a step further. Its <code>BaseModel</code> is composed of two sub-models. The <code>listModel</code> is even an input for the detail-presenter.</p> <pre><code>val listModel = userPageListPresenter.present(UserPageListPresenter.Input(user))\nreturn Model(\n  listModel = listModel,\n  detailModel =\n    userPageDetailPresenter.present(\n      UserPageDetailPresenter.Input(user, selectedAttribute = listModel.selectedIndex)\n    ),\n)\n</code></pre> <p>This concept allows us to implement model-driven navigation. By driving the entire UI layer through <code>Presenters</code> and emitted <code>Models</code> navigation becomes a first class API and testable. Imagine having a root presenter implementing a back stack that forwards the model of the top most presenter. When the user navigates to a new screen, then the root presenter would add a new presenter to the stack and provide its model object.</p> <pre><code>%%{init: {'themeCSS': '.label { font-family: monospace; }'}}%%\ngraph TD\n  login[\"`Login presenter`\"]\n  registration[\"`Register presenter`\"]\n  onboarding[\"`Onboarding presenter`\"]\n  delivery[\"`Delivery presenter`\"]\n  settings[\"`Settings presenter`\"]\n  root[\"`Root presenter`\"]\n  ui[\"`UI Layer`\"]\n\n  login --&gt; onboarding\n  registration --&gt; onboarding\n  onboarding --&gt; root\n  delivery --&gt; root\n  settings --&gt; root\n  root --&gt; ui\n\n  style ui stroke:#0f0</code></pre> <p>In the example above, the root presenter would forward the model of the onboarding, delivery or settings presenter to the UI layer. The onboarding presenter as shown in the code example can either call the login or registration presenter based on a condition. With Molecule calling a child presenter is as easy as invoking a function.</p>"},{"location":"presenter/#parent-child-communication","title":"Parent child communication","text":"<p>While the pattern isn\u2019t used frequently, parent presenters can provide input to their child presenters. The returned model from the child presenter can be used further to change the control flow.</p> <pre><code>interface ChildPresenter : MoleculePresenter&lt;Input, Model&gt; {\n  data class Input(\n    val argument: String,\n  )\n}\n\nclass ParentPresenterImpl(\n  private val lazyChildPresenter: () -&gt; ChildPresenter\n) : ParentPresenter {\n\n  @Composable\n  fun present(input: Unit) {\n    val childPresenter = remember { lazyChildPresenter() }\n    val childModel = childPresenter.present(Input(argument = \"abc\"))\n\n    return if (childModel...) ...\n  }\n}\n</code></pre> <p>This mechanism is favored less, because it only allows for direct parent to child presenter interactions and becomes hard to manage for deeply nested hierarchies. More often a service object is injected instead, which is used by the multiple presenters:</p> <pre><code>interface AccountManager {\n  val currentAccount: StateFlow&lt;Account&gt;\n\n  fun mustRegister(): Boolean\n}\n\nclass AmazonLoginPresenter(\n  private val accountManager: AccountManager\n): LoginPresenter {\n  @Composable\n  fun present(input: Unit): Model {\n    val account by accountManager.currentAccount.collectAsState()\n    ...\n  }\n}\n\nclass OnboardingPresenterImpl(\n  private val lazyLoginPresenter: () -&gt; LoginPresenter,\n  private val lazyRegistrationPresenter: () -&gt; RegistrationPresenter,\n  private val accountManager: AccountManager,\n) : OnboardingPresenter {\n\n  @Composable\n  fun present(input: Unit): BaseModel {\n    val account by accountManager.currentAccount.collectAsState()\n    ...\n\n    return if (accountManager.mustRegister()) {\n      val registrationPresenter = remember { lazyRegistrationPresenter() }\n      registrationPresenter.present(Unit)\n    } else {\n      val loginPresenter = remember { lazyLoginPresenter() }\n      loginPresenter.present(Unit)\n    }\n  }\n}\n</code></pre> <p>This example shows how <code>AccountManager</code> holds state and is injected into multiple presenters instead of relying on presenter inputs.</p>"},{"location":"presenter/#launching","title":"Launching","text":"<p><code>MoleculePresenters</code> can inject other presenters and call their <code>present()</code> function inline. If you are already in a composable UI context, then you can simply call the presenter to compute the model:</p> <pre><code>fun mainViewController(): UIViewController = ComposeUIViewController {\n  val presenter = remember { LoginPresenter() }\n  val model = presenter.present(Unit)\n  ...\n}\n</code></pre> <p>In this example the <code>LoginPresenter</code> model is computed from an iOS Compose Multiplatform function.</p> <p>In other scenarios a composable context may not be available and it\u2019s necessary to turn the <code>@Composable</code> functions into a <code>StateFlow</code> for consumption.</p> <p><code>MoleculeScope</code> helps to turn a <code>MoleculePresenter</code> into a <code>Presenter</code>, which then exposes a <code>StateFlow</code>:</p> <pre><code>val stateFlow = moleculeScope\n  .launchMoleculePresenter(\n    presenter = myPresenter,\n    input = Unit,\n  )\n  .model\n</code></pre> <p>Warning</p> <p><code>MoleculeScope</code> wraps a <code>CoroutineScope</code>. The presenter keeps running, recomposing and producing new models until the <code>MoleculeScope</code> is canceled. If the <code>MoleculeScope</code> is never canceled, then presenters leak and will cause issues later.</p> <p>Use <code>MoleculeScopeFactory</code> to create a new <code>MoleculeScope</code> instance and call <code>cancel()</code> when you don\u2019t need it anymore.</p> <p>On Android an implementation using <code>ViewModels</code> may look like this:</p> <pre><code>class MainActivityViewModel(\n  moleculeScopeFactory: MoleculeScopeFactory,\n  myPresenter: MyPresenter,\n) : ViewModel() {\n\n  private val moleculeScope = moleculeScopeFactory.createMoleculeScope()\n\n  // Expose the models for consumption.\n  val models = moleculeScope\n    .launchMoleculePresenter(\n      presenter = myPresenter,\n      input = Unit\n    )\n    .models\n\n  override fun onCleared() {\n    moleculeScope.cancel()\n  }\n}\n</code></pre> <p>Info</p> <p>By default <code>MoleculeScope</code> uses the main thread for running presenters and <code>RecompositionMode.ContextClock</code>, meaning a new model is produced only once per UI frame and further changes are conflated.</p> <p>This behavior can be changed by creating a custom <code>MoleculeScope</code>, e.g. tests make use of this:</p> <pre><code>fun TestScope.moleculeScope(\n  coroutineContext: CoroutineContext = EmptyCoroutineContext\n): MoleculeScope {\n  val scope = backgroundScope + CoroutineName(\"TestMoleculeScope\") + coroutineContext\n\n  return MoleculeScope(scope, RecompositionMode.Immediate)\n}\n</code></pre>"},{"location":"presenter/#testing","title":"Testing","text":"<p>A <code>test()</code> utility function is provided to make testing <code>MoleculePresenters</code> easy using the Turbine library:</p> <pre><code>class LoginPresenterImplTest {\n\n  @Test\n  fun `after 1 second the user is logged in after pressing the login button`() = runTest {\n    val userManager = FakeUserManager()\n\n    LoginPresenterImpl(userManager).test(this) {\n      val firstModel = awaitItem()\n      ...\n    }\n  }\n}\n</code></pre> <p>The <code>test()</code> function uses the <code>TestScope.backgroundScope</code> to run the presenter.</p> Sample <p>The sample application implements multiple tests for its presenters, e.g. <code>LoginPresenterImplTest</code>, <code>NavigationPresenterImplTest</code> and <code>UserPagePresenterImplTest</code>.</p>"},{"location":"presenter/#back-gestures","title":"Back gestures","text":"<p><code>Presenters</code> support back gestures with a similar API in terms of syntax and semantic to Compose Multiplatform. Any <code>Presenter</code> can call these functions:</p> <pre><code>@Composable\nfun present(input: Unit): Model {\n  BackHandlerPresenter {\n    // Handle a back press.  \n  }\n\n  PredictiveBackHandlerPresenter { progress: Flow&lt;BackEventCompat&gt; -&gt;\n    // code for gesture back started\n    try {\n      progress.collect { backevent -&gt;\n        // code for progress\n      }\n      // code for completion\n    } catch (e: CancellationException) {\n      // code for cancellation\n    }\n  }  \n}\n</code></pre> <p>Warning</p> <p>Notice <code>Presenter</code> suffix in these function names. These functions should not be confused with <code>BackHandler {}</code> and <code>PredictiveBackHandler {}</code> coming from Compose Multiplatform or Compose UI Android, which would fail at runtime  when called from a <code>Presenter</code>.</p> <p>Calling these functions requires <code>BackGestureDispatcherPresenter</code> to be setup as composition local. This is usually done from the root presenter in your hierarchy. An instance of <code>BackGestureDispatcherPresenter</code> is provided by App Platform in the application scope and can be injected:</p> <pre><code>@Inject\nclass RootPresenter(\n  private val backGestureDispatcherPresenter: BackGestureDispatcherPresenter,\n) : MoleculePresenter&lt;Unit, Model&gt; {\n  @Composable\n  override fun present(input: Unit): Model {\n    return returningCompositionLocalProvider(\n      LocalBackGestureDispatcherPresenter provides backGestureDispatcherPresenter\n    ) {\n      // Call other child presenters.\n    }\n  }\n}\n</code></pre> <p>The last step is to forward back gestures from the UI layer to <code>Presenters</code> to invoke the callbacks in the <code>Presenters</code>. Here again it\u2019s recommended to do this from within the root <code>Renderer</code>:</p> <pre><code>@Inject\n@ContributesRenderer\nclass RootPresenterRenderer(\n  private val backGestureDispatcherPresenter: BackGestureDispatcherPresenter,\n) : ComposeRenderer&lt;Model&gt;() {\n  @Composable\n  override fun Compose(model: Model) {\n    backGestureDispatcherPresenter.ForwardBackPressEventsToPresenters()\n\n    // Call other child renderers.\n  }\n}\n</code></pre> <p>A similar built-in integration is provided for Android Views. There it\u2019s recommended to call this function from each Android <code>Activity</code>:</p> <pre><code>class MainActivity : ComponentActivity() {\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n\n    backGestureDispatcherPresenter.forwardBackPressEventsToPresenters(this)\n    // ...\n  }\n}\n</code></pre> <p>Unit tests verifying the behavior of a <code>Presenter</code> using the back handler APIs need to provide the composition local as well. This can be achieved by wrapping the <code>Presenter</code> with <code>withBackGestureDispatcher()</code>:</p> <pre><code>class MyPresenterTest {\n\n  @Test\n  fun `test back handler`() = runTest {\n    val presenter = MyPresenter()\n\n    presenter.withBackGestureDispatcher().test(this) {\n      // Verify the produced models from the presenter.\n    }\n  }\n}\n</code></pre> Sample <p>The <code>BackHandlerPresenter {}</code> call has been integrated in the sample application with this recommended setup. All necessary changes are part of this commit.</p> <p>The same setup has been integrated in the recipes app part of this commit as well. </p>"},{"location":"presenter/#compose-runtime","title":"Compose runtime","text":"<p>One of the major benefits of using Compose through Molecule is how the framework turns reactive streams such as <code>Flow</code> and <code>StateFlow</code> into imperative code, which then becomes easier to understand, write and maintain. Composable functions have a lifecycle, they enter a composition (the presenter starts to be used) and leave a composition (the presenter is no longer used). Properties can be made reactive and trigger creating a new <code>Model</code> whenever they change.</p>"},{"location":"presenter/#lifecycle","title":"Lifecycle","text":"<p>This example contains two child presenters:</p> <pre><code>class OnboardingPresenterImpl(\n  private val lazyLoginPresenter: () -&gt; LoginPresenter,\n  private val lazyRegistrationPresenter: () -&gt; RegistrationPresenter,\n) : OnboardingPresenter {\n\n  @Composable\n  fun present(input: Unit): BaseModel {\n    ...\n    return if (mustRegister) {\n      val registrationPresenter = remember { lazyRegistrationPresenter() }\n      registrationPresenter.present(Unit)\n    } else {\n      val loginPresenter = remember { lazyLoginPresenter() }\n      loginPresenter.present(Unit)\n    }\n  }\n}\n</code></pre> <p>On the first composition, when <code>OnboardingPresenterImpl.present()</code> is called for the first time, the lifecycle of <code>OnboardingPresenterImpl</code> starts. Let\u2019s assume <code>mustRegister</code> is true, then <code>RegistrationPresenter</code> gets called and its lifecycle starts as well. In the example when <code>mustRegister</code> switches to false, then <code>RegistrationPresenter</code> leaves the composition and its lifecycle ends. <code>LoginPresenter</code> enters the composition and its lifecycle starts. If the parent presenter of <code>OnboardingPresenterImpl</code> stops calling this presenter, then <code>OnboardingPresenterImpl</code> and <code>LoginPresenter</code> would leave composition and both of their lifecycles end.</p>"},{"location":"presenter/#state","title":"State","text":"<p>Google\u2019s guide for state management is a good starting point. APIs most often used are <code>remember()</code>, <code>mutableStateOf()</code>, <code>collectAsState()</code> and <code>produceState()</code>.</p> <pre><code>@Composable\nfun present(input: Unit): Model {\n  var toggled: Boolean by remember { mutableStateOf(false) }\n\n  return Model(\n    text = if (toggled) \"toggled\" else \"not toggled\",\n  ) {\n    when (it) {\n      is ToggleClicked -&gt; toggled = !toggled\n    }\n  }\n}\n</code></pre> <p>In this example, whenever the Presenter receives the <code>ToggleClicked</code> event, then the state <code>toggled</code> changes. This triggers a recomposition in the Compose runtime and will call <code>present()</code> again to compute a new <code>Model</code>.</p> <p><code>Flows</code> can easily be observed using <code>collectAsState()</code>:</p> <pre><code>interface AccountManager {\n  val currentAccount: StateFlow&lt;Account&gt;\n}\n\nclass AmazonLoginPresenter(\n  private val accountManager: AccountManager\n): LoginPresenter {\n  @Composable\n  fun present(input: Unit): Model {\n    val account: Account by accountManager.currentAccount.collectAsState()\n    ...\n  }\n}\n</code></pre> <p>Whenever the <code>currentAccount</code> Flow emits a new <code>Account</code>, then the Compose runtime will trigger a recomposition and a new <code>Model</code> will be computed.</p>"},{"location":"presenter/#side-effects","title":"Side effects","text":"<p>It\u2019s recommended to read Google\u2019s guide. Since composable functions come with a lifecycle, async operations can safely be launched and get automatically torn down when the <code>Presenter</code> leaves the composition. Commonly used APIs are <code>LaunchedEffect()</code>, <code>DisposableEffect()</code> and <code>rememberCoroutineScope()</code>.</p> <pre><code>@Composable\nfun present(input: Unit): Model {\n  LaunchedEffect(key) {\n    // This is within a CoroutineScope and suspending functions can\n    // be called:\n    flowOf(1, 2, 3).collect { ... }\n  }\n}\n</code></pre> <p>If the <code>key</code> changes between compositions, then a new coroutine is launched and the previous one canceled. For more details see here.</p> <p>This is an example for how one would use <code>rememberCoroutineScope()</code>:</p> <pre><code>@Composable\nfun present(input: Unit): Model {\n  val coroutineScope = rememberCoroutineScope()\n\n  return Model() {\n    when (it) {\n      is OnClick -&gt; coroutineScope.launch { ... }\n    }\n  }\n}\n</code></pre> <p>When the <code>Presenter</code> leaves composition, then all jobs launched by this coroutine scope get canceled. For more details see here.</p>"},{"location":"presenter/#recipes","title":"Recipes","text":"<p>There are common scenarios you may encounter when using <code>Presenters</code>.</p> <p>Info</p> <p>The recipes below are not part of the App Platform API and we look for feedback. The solutions are either implemented in the Recipes or Sample app. Please let us know if these solutions work for you or which use cases you\u2019re missing.</p> <p>The Recipes app and Sample app can be tested in the browser.</p>"},{"location":"presenter/#save-presenter-state","title":"Save <code>Presenter</code> state","text":"<p><code>Presenters</code> can make full use of the Compose runtime, e.g. using <code>remember { }</code> and <code>mutableStateOf()</code>. But when a <code>Presenter</code> leaves the composition and no longer is part of the hierarchy, then it loses its state and would be called with the initial state the next time.</p> <pre><code>@Composable\nfun present(input: Unit): Model {\n  val showLogin = ...\n\n  val model = if (showLogin) {\n    loginPresenter.present(Unit)\n  } else {\n    registerPresenter.present(Unit)\n  }\n\n  return model\n}\n</code></pre> <p>Take this function for example. Every time <code>showLogin</code> is toggled then either <code>loginPresenter</code> or <code>registerPresenter</code> is called with their initial state. These presenters only remember their state, if <code>showLogin</code> doesn\u2019t change.</p> <p>The Compose runtime provides <code>rememberSaveable { }</code> and <code>SaveableStateHolder</code> as solution to save and restore instance state within a process or across process death. The Recipes app ported <code>SaveableStateHolder</code> to work for <code>@Composable</code> functions that must return a value. <code>Presenters</code> wrapped with a <code>ReturningSaveableStateHolder</code> can use <code>rememberSaveable { }</code> to restore state even after they weren\u2019t part of the hierarchy anymore:</p> <pre><code>@Composable\nfun present(input: Unit): Model {\n  val showLogin = ...\n\n  val model = if (showLogin) {\n    loginPresenter.present(Unit)\n  } else {\n    registerPresenter.present(Unit)\n  }\n\n  val saveableStateHolder = rememberReturningSaveableStateHolder()\n\n  val presenter = if (showLogin) loginPresenter else registerPresenter\n\n  return saveableStateHolder.SaveableStateProvider(key = presenter) {\n    presenter.present(Unit)\n  }\n}\n</code></pre> <p>State wrapped in <code>rememberSaveable { }</code> in <code>LoginPresenter</code> and <code>RegisterPresenter</code> will be preserved no matter how often <code>showLogin</code> is toggled.</p>"},{"location":"presenter/#presenter-backstack","title":"<code>Presenter</code> backstack","text":"<p>With <code>Presenters</code> it\u2019s easy to implement model driven navigation. Which <code>Presenter</code> is shown on screen is part of the business logic.</p> <pre><code>@Composable\nfun present(input: Unit): Model {\n  val showLogin = ...\n\n  val model = if (showLogin) {\n    loginPresenter.present(Unit)\n  } else {\n    registerPresenter.present(Unit)\n  }\n\n  return model\n}\n</code></pre> <p>This pattern can be generalized:</p> <pre><code>interface NavigationManager {\n  val currentPresenter: StateFlow&lt;MoleculePresenter&lt;Unit, BaseModel&gt;&gt;\n\n  fun navigateTo(presenter: MoleculePresenter&lt;Unit, BaseModel&gt;)\n}\n\n@Inject\nclass NavigationPresenter(val navigationManager: NavigationManager) : MoleculePresenter&lt;Unit, BaseModel&gt; {\n\n  @Compose\n  fun present(input: Unit): BaseModel {\n    val presenter by navigationManager.currentPresenter.collectAsState()\n    return presenter.present(Unit)\n  }\n}\n</code></pre> <p>This solution always shows the <code>Presenter</code> for which <code>navigateTo()</code> was called last. This function can be called from anywhere in the app.</p> <p>Another solution is a backstack of <code>Presenters</code>, where <code>Presenters</code> can be pushed to the stack and the top most <code>Presenter</code> can be popped from the stack. The Recipes app implemented this navigation pattern with an easy to use <code>presenterBackstack { }</code> function:</p> <pre><code>class CrossSlideBackstackPresenter(\n  private val initialPresenter: MoleculePresenter&lt;Unit, out BaseModel&gt;\n) : MoleculePresenter&lt;Unit, Model&gt; {\n  @Composable\n  override fun present(input: Unit): Model {\n    return presenterBackstack(initialPresenter) { model -&gt;\n      // Pop the top presenter on a back press event.\n      BackHandlerPresenter(enabled = lastBackstackChange.value.backstack.size &gt; 1) {\n        pop()\n      }\n\n      Model(delegate = model, backstackScope = this)\n    }\n  }\n}\n</code></pre> <p><code>presenterBackstack { }</code> provides PresenterBackstackScope, which allows you to <code>push()</code> and <code>pop()</code> presenters. Child presenters wrapped in this function get access to this scope using a composition local:</p> <pre><code>@Composable\noverride fun present(input: Unit): Model {\n  val backstack = checkNotNull(LocalBackstackScope.current)\n  ...\n\n  return Model() {\n    when (it) {\n      Event.AddPresenterToBackstack -&gt; backstack.push(BackstackChildPresenter())\n    }\n  }\n}\n</code></pre> <p><code>CrossSlideBackstackPresenter</code> from the Recipe app goes one step further and integrates the <code>BackHandlerPresenter { }</code> API to pop presenters from the stack when the back button is pressed. Its <code>Renderer</code> implements a slide animation whenever a presenter is pushed to the stack or popped from the stack.</p>"},{"location":"presenter/#compositionlocal","title":"<code>CompositionLocal</code>","text":"<p>Both the <code>BackHandlerPresenter { }</code> integration for back button presses and the backstack recipe for navigation leverage Compose\u2019s <code>CompositionLocal</code> feature. This is a powerful mechanism to provide state from a parent presenter to nested child presenters even deep down in the stack without relying on the <code>Input</code> parameter of presenters or providing dependencies through the constructor. Another benefit is that <code>CompositionLocals</code> are embedded in the presenter tree and multiple instances can be provided for different parts of the tree or even be overridden, e.g. a parent presenter may use a backstack, but then a child presenter may provide its own backstack for its child presenters.</p> <p>A common implementation may look like this:</p> <pre><code>class YourType\n\npublic val LocalYourType: ProvidableCompositionLocal&lt;YourType?&gt; = compositionLocalOf { null }\n\nclass ParentPresenter : MoleculePresenter&lt;Unit, Model&gt; {\n  @Composable\n  override fun present(input: Unit): Model {\n    val yourType = remember { YourType() }\n\n    return returningCompositionLocalProvider(\n      LocalYourType provides yourType\n    ) {\n      // ... call child presenters\n    }\n  }\n}\n\nclass ChildPresenter : MoleculePresenter&lt;Unit, Model&gt; {\n  @Composable\n  override fun present(input: Unit): Model {\n    val yourType = checkNotNull(LocalYourType.current)\n    ...\n  }\n}\n</code></pre> <p>While <code>CompositionLocals</code> are powerful, their biggest downsides are unit tests. In a unit test for <code>ChildPresenter</code> a value for <code>LocalYourType.current</code> must be provided, otherwise the call will throw an exception.</p>"},{"location":"presenter/#app-bar","title":"App Bar","text":"<p>The Recipes app implements an app bar for all its screens and allows child presenters to change the content.</p> <p>There are multiple ways to implement the app bar and decompose the different screen elements. One way is using Templates, where one slot in the template is reserved for the app bar model. A specific <code>Presenter</code> could be responsible for providing this model:</p> <pre><code>sealed interface SampleAppTemplate : Template {\n\n  data class FullScreenTemplate(\n    val appBarModel: AppBarModel\n    val content: BaseModel,\n  ) : SampleAppTemplate\n}\n\nclass SampleAppTemplatePresenter(\n  private val appBarPresenter: AppBarPresenter,\n  private val rootPresenter: MoleculePresenter&lt;Unit, BaseModel&gt;,\n) : MoleculePresenter&lt;Unit, SampleAppTemplate&gt; {\n  @Composable\n  fun present(input: Unit): SampleAppTemplate {\n    val contentModel = rootPresenter.present(Unit)\n\n    return contentModel.toTemplate { model -&gt;\n      val appBarModel = appBarPresenter.present(Unit)\n      FullScreenTemplate(appBarModel, contentModel)\n    }\n  }\n}\n</code></pre> <p>The <code>SampleAppTemplateRenderer</code> has access to <code>appBarModel</code> from the <code>FullScreenTemplate</code> and can use the model to configure the app bar UI.</p> <p>The Recipe app has chosen a different implementation, where any <code>BaseModel</code> class from a <code>Presenter</code> can implement the specific <code>AppBarConfigModel</code> interface, which provides the configuration for the app bar. Implementing this interface is optional:</p> <pre><code>class MenuPresenter : MoleculePresenter&lt;Unit, Model&gt; {\n  @Composable\n  override fun present(input: Unit): Model {\n    ...\n  }\n\n  data class Model(\n    private val menuItems: List&lt;AppBarConfig.MenuItem&gt;,\n  ) : BaseModel, AppBarConfigModel {\n    override fun appBarConfig(): AppBarConfig {\n      return AppBarConfig(title = \"Menu items\", menuItems = menuItems)\n    }\n  }\n}\n</code></pre> <p>If a <code>BaseModel</code> implementing <code>AppBarConfigModel</code> bubbles all the way up to the <code>RootPresenter</code>, then the <code>BaseModel</code> from the child <code>Presenter</code> will provide the config for the <code>Template</code> or otherwise the <code>RootPresenter</code> will provide a default:</p> <pre><code>return contentModel.toTemplate { model -&gt;\n  val appBarConfig =\n    if (model is AppBarConfigModel) {\n      model.appBarConfig().copy(backArrowAction = backArrowAction)\n    } else {\n      AppBarConfig(title = AppBarConfig.DEFAULT.title, backArrowAction = backArrowAction)\n    }\n\n  RecipesAppTemplate.FullScreenTemplate(model, appBarConfig)\n}\n</code></pre>"},{"location":"presenter/#navigation-3","title":"Navigation 3","text":"<p>The Navigation 3 library can be used with App Platform. For idiomatic navigation App Platform recommends handling navigation events in  <code>Presenters</code>. <code>Presenters</code> are composable, build a tree and can delegate which <code>Presenter</code> is shown on screen to child  <code>Presenters</code>. This is how App Platform implements a unidirectional dataflow. The downside of Navigation 3 is that  it pushes navigation logic into the Compose UI layer, which is against App Platform\u2019s philosophy of handling navigation  in the business logic. With the right integration strategy, this downside can be mitigated.</p> <p>The Recipes app manages the backstack of <code>Presenters</code> in the parent  <code>Navigation3HomePresenter</code> and forwards the backstack and options to modify the stack to the <code>Renderer</code>. Note that the <code>Model</code> is computed for  each <code>Presenter</code> in the backstack:</p> <pre><code>@Composable\noverride fun present(input: Unit): Model {\n  val backstack = remember {\n    mutableStateListOf&lt;MoleculePresenter&lt;Unit, out BaseModel&gt;&gt;().apply {\n      // There must be always one element.\n      add(Navigation3ChildPresenter(index = 0, backstack = this))\n    }\n  }\n\n  return Model(backstack = backstack.map { it.present(Unit) }) {\n    when (it) {\n      Event.Pop -&gt; {\n        backstack.removeAt(backstack.size - 1)\n      }\n    }\n  }\n}\n</code></pre> <p>The <code>Renderer</code>  wraps the backstack in a <code>NavDisplay</code> and forwards back gestures to the <code>Presenter</code>. There is a unique <code>NavEntry</code> for each position in the stack and the individual <code>Renderer</code> for each <code>Model</code> is invoked:</p> <pre><code>@Inject\n@ContributesRenderer\nclass AndroidNavigation3HomeRenderer(private val rendererFactory: RendererFactory) : ComposeRenderer&lt;Model&gt;() {\n  @Composable\n  override fun Compose(model: Model) {\n    // Use the position of the model in the backstack as key for `NavDisplay`. This way\n    // we can update models without Navigation 3 treating those changes as a new screen.\n    val backstack = model.backstack.mapIndexed { index, _ -&gt; index }\n\n    NavDisplay(\n      backStack = backstack,\n      onBack = { model.onEvent(Event.Pop) },\n      entryProvider = { key -&gt;\n        NavEntry(key) {\n          val model = model.backstack[it]\n          rendererFactory.getComposeRenderer(model).renderCompose(model)\n        }\n      },\n    )\n  }\n}\n</code></pre> <p>With this integration handling of the backstack is managed in the <code>Presenter</code> and testable. </p> Alternative integration <p>If a unidirectional dataflow isn\u2019t required, an alternative integration is making each <code>NavEntry</code> a unique  <code>Presenter</code> root and compute the <code>Model</code> directly using the <code>Presenter</code>. For the reasons mentioned we don\u2019t  recommend this setup.</p> <pre><code>data object List\ndata object Detail\n\n@Inject\n@ContributesRenderer\nclass Navigation3Renderer(\n  private val listPresenter: ListPresenter,\n  private val detailPresenter: DetailPresenter,\n  private val rendererFactory: RendererFactory,\n) : ComposeRenderer&lt;Model&gt;() {\n  @Composable\n  override fun Compose(model: Model) {\n    val backstack = remember { mutableStateListOf&lt;Any&gt;(List) }\n\n    NavDisplay(\n      backStack = backstack,\n      onBack = { backstack.removeAt(backstack.size - 1) },\n      entryProvider =\n        entryProvider {\n          entry&lt;List&gt; {\n            val model = listPresenter.present(Unit)\n            rendererFactory.getComposeRenderer(model).renderCompose(model)\n          }\n          entry&lt;Detail&gt; {\n            val model = detailPresenter.present(Unit)\n            rendererFactory.getComposeRenderer(model).renderCompose(model)\n          }\n        },\n    )\n  }\n}\n</code></pre>"},{"location":"presenter/#swiftui","title":"SwiftUI","text":""},{"location":"presenter/#presenters-and-swiftui-views","title":"<code>Presenters</code> and SwiftUI <code>Views</code>","text":"<p>In iOS it\u2019s possible to connect <code>Presenters</code> to SwiftUI <code>Views</code> so <code>Presenter</code> logic can be shared while keeping UI native. The Recipes app demonstrates a set of Swift APIs that demonstrate how to launch a <code>Presenter</code> and render SwiftUI <code>Views</code> in the iOS flavor. Note that App Platform  does not provide an API equivalent of SwiftUI <code>Renderers</code>. As such, we need to decide how to observe the flow of models  from a given <code>Presenter</code> and create <code>Views</code> from them.</p> <p>To obtain an observable stream of models, <code>Presenter</code> can be extended to provide an <code>AsyncThrowingStream</code> from the  model <code>StateFlow</code>. It\u2019s also possible to implement a convenient extension of <code>Flow</code> so we can convert any <code>Flow</code> to an <code>AsyncThrowingStream</code>.</p> <pre><code>extension Presenter {\n    func viewModels&lt;Model&gt;(ofType type: Model.Type) -&gt; AsyncThrowingStream&lt;Model, Error&gt; {\n        model\n            .values()\n            .compactMap { $0 as? Model }\n            .asAsyncThrowingStream()\n    }\n}\n\nextension Kotlinx_coroutines_coreFlow {\n    /// The Flows send Any, so we lose type information and need to cast at runtime instead of getting a type-safe compile time check.\n    func values() -&gt; AsyncThrowingStream&lt;Any?, Error&gt; {\n        let collector = Kotlinx_coroutines_coreFlowCollectorImpl&lt;Any?&gt;()\n        collect(collector: collector, completionHandler: collector.onComplete(_:))\n        return collector.values\n    }\n}\n</code></pre> <p>Given a <code>Model</code> there are multiple ways to implement association with some SwiftUI <code>View</code>. The Recipes app chooses to create a <code>protocol</code> for view creation and extend <code>BaseModel</code> to create views under the requirement of its conformance:</p> <pre><code>protocol PresenterViewModel {\n    associatedtype Renderer : View\n    @ViewBuilder @MainActor func makeViewRenderer() -&gt; Self.Renderer\n}\n\nextension BaseModel {\n    @MainActor func getViewRenderer() -&gt; AnyView {\n        guard let viewModel = self as? (any PresenterViewModel) else {\n            assertionFailure(\"ViewModel \\(self) does not conform to `PresenterViewModel`\")\n\n            // This is an implementation detail. If crashing is preferred even in production builds, `fatalError(..)`\n            // can be used instead\n            return AnyView(Text(\"Error, some ViewModel was not implemented!\"))\n        }\n\n        return AnyView(viewModel.makeViewRenderer())\n    }\n}\n</code></pre> Alternate implementation <p>We can also create a <code>View</code> registry:</p> <pre><code>public class PresenterViewRegistry {\n    @MainActor private var registry: [ObjectIdentifier: (Any) -&gt; AnyView] = [:]\n\n    public init(registry: [ObjectIdentifier : (Any) -&gt; AnyView] = [:]) {\n        self.registry = registry\n    }\n\n    public static var shared: PresenterViewRegistry = PresenterViewRegistry()\n}\n\n@MainActor public extension PresenterViewRegistry {\n    func registerViewForModelType&lt;Model, Content: View&gt;(_ type: Model.Type, makeView: @escaping (Model) -&gt; Content) {\n        let typeID = ObjectIdentifier(Model.self)\n        registry[typeID] = { model in\n            AnyView(makeView(model as! Model))\n        }\n    }\n\n    func makeViewForModel&lt;Model&gt;(_ model: Model) -&gt; some View {\n        let type = type(of: model as Any)\n        let typeID = ObjectIdentifier(type)\n        if let makeView = registry[typeID] {\n            return makeView(model)\n        }\n        fatalError(\"Could not find view builder for \\(type). Add it to the registry.\")\n    }\n}\n</code></pre> <p>The registry can be stored in an <code>Environment</code> property wrapper. This is similar to how <code>@ContributesRenderer</code> works  under the hood, though without an equivalent App Platform API the heavy lifting on registration and registry  lifecycle management falls to consumers. Due to these reasons we generally recommend to use the protocol setup.</p>"},{"location":"presenter/#navigation-with-presenters-and-swiftui","title":"Navigation with <code>Presenters</code> and SwiftUI","text":"<p>SwiftUI provides navigation containers to enable movement between different part of an app\u2019s view hierarchy. Similar to <code>Navigation 3</code>, SwiftUI\u2019s navigation containers  push navigation logic to the UI layer, which is against App Platform\u2019s philosophy of handling navigation in business logic. However, to support navigation with SwiftUI <code>Views</code> and <code>Presenters</code>, it is recommended to integrate with  SwiftUI\u2019s navigation offerings. This SwiftUI keeps the determination of some completed back gesture an implementation detail, and we want ensure that all back events are handled appropriately and the user experience feels truly native.</p> <p>Note</p> <p>We provide a recipe for integration with <code>NavigationStack</code> for single column navigation based on back gesture. For  other kinds of navigation with <code>NavigationSplitView</code> or <code>NavigationLink</code> it is possible to integrate following our model driven navigation pattern. However, we don\u2019t provide an explicit recipe for it. If you\u2019re missing some use cases here, please let us know.</p> <p>The Recipes app demonstrates how SwiftUI navigation APIs can be used while following App Platform\u2019s philosophy of  unidirectional data flow. As navigation is a part of business logic, the recipe implements navigation with  a backstack of <code>Presenters</code>. The root <code>Presenter</code> responsible for the <code>Presenter</code> backstack computes the <code>Model</code> backstack:</p> <p><pre><code>@Composable\n  override fun present(input: Unit): Model {\n    val backstack = remember {\n      mutableStateListOf&lt;MoleculePresenter&lt;Unit, out BaseModel&gt;&gt;().apply {\n        // There must be always one element.\n        add(SwiftUiChildPresenter(index = 0, backstack = this))\n      }\n    }\n\n    return Model(modelBackstack = backstack.map { it.present(Unit) }) {\n      when (it) {\n        is Event.BackstackModificationEvent -&gt; {\n          val updatedBackstack = it.indicesBackstack.map { index -&gt; backstack[index] }\n\n          backstack.clear()\n          backstack.addAll(updatedBackstack)\n        }\n      }\n    }\n  }\n</code></pre> The <code>Presenter</code> forwards the <code>Models</code> and event callbacks to a SwiftUI <code>View</code>, which integrates these models with a <code>NavigationStack</code>. Note that to integrate we create a <code>Binding</code> that is passed in to the <code>NavigationStack</code>. The <code>Binding's</code> value type must conform to <code>Hashable</code> and by default <code>BaseModel</code> does not conform. To resolve this in the recipe we simply represent each <code>Model</code> by the index of its position in the <code>Model</code> backstack as we do not require more complex identifiers.</p> <pre><code>extension SwiftUiHomePresenter.Model {\n    func pathBinding() -&gt; Binding&lt;[Int]&gt; {\n        .init {\n            // drop the first value of the backstack from the path because that should be the root view\n            Array(self.modelBackstack.indices.dropFirst())\n        } set: { modifiedIndices in\n\n            // the resulting backstack indices the presenter should compute on is the first index (0) that was\n            // dropped as well as the remaining indices post modification\n            let indicesBackstack = [0] + modifiedIndices.map { $0.toKotlinInt() }\n\n            self.onEvent(\n                SwiftUiHomePresenterEventBackstackModificationEvent (\n                    indicesBackstack: indicesBackstack\n                )\n            )\n        }\n    }\n}\n\nprivate struct NavigationStackView: View {\n    var backstack: [BaseModel]\n    var model: SwiftUiHomePresenter.Model\n\n    init(model: SwiftUiHomePresenter.Model) {\n        self.backstack = model.modelBackstack\n        self.model = model\n    }\n\n    var body: some View {\n        NavigationStack(path: model.pathBinding()) {\n            backstack[0].getViewRenderer()\n                .navigationDestination(for: Int.self) { index in\n                    backstack[index].getViewRenderer()\n                }\n        }\n    }\n}\n</code></pre>"},{"location":"renderer/","title":"Renderer","text":"<p>Note</p> <p>App Platform has a generic <code>Renderer</code> interface that can be used for multiple UI layer implementations. Compose Multiplatform and Android Views are stable and supported out of the box. However, Compose Multiplatform is an opt-in feature through the Gradle DSL and must be explicitly enabled. The default value is <code>false</code>.</p> <pre><code>appPlatform {\n  enableComposeUi true\n}\n</code></pre>"},{"location":"renderer/#renderer-basics","title":"Renderer basics","text":"<p>A <code>Renderer</code> is the counterpart to a <code>Presenter</code>. It consumes <code>Models</code> and turns them into UI, which is shown on screen.</p> <pre><code>interface Renderer&lt;in ModelT : BaseModel&gt; {\n  fun render(model: ModelT)\n}\n</code></pre> <p>The <code>Renderer</code> interface is rarely used directly, instead platform specific implementations like <code>ComposeRenderer</code> for Compose Multiplatform and <code>ViewRenderer</code> for Android are used. App Platform doesn\u2019t provide any other implementations for now, e.g. a SwiftUI or UIKit implementation for iOS is missing.</p> ComposeRenderer<pre><code>@ContributesRenderer\nclass LoginRenderer : ComposeRenderer&lt;Model&gt;() {\n  @Composable\n  override fun Compose(model: Model) {\n    if (model.loginInProgress) {\n      CircularProgressIndicator()\n    } else {\n      Text(\"Login\")\n    }\n  }\n}\n</code></pre> ViewRenderer<pre><code>@ContributesRenderer\nclass LoginRenderer : ViewRenderer&lt;Model&gt;() {\n    private lateinit var textView: TextView\n\n    override fun inflate(\n        activity: Activity,\n        parent: ViewGroup,\n        layoutInflater: LayoutInflater,\n        initialModel: Model,\n    ): View {\n        return TextView(activity).also { textView = it }\n    }\n\n    override fun renderModel(model: Model) {\n        textView.text = \"Login\"\n    }\n}\n</code></pre> <p>Warning</p> <p>Note that <code>ComposeRenderer</code> like <code>ViewRenderer</code> implements the common <code>Renderer</code> interface, but calling the <code>render(model)</code> function is an error. Instead, <code>ComposeRenderer</code> defines its own function to preserve the composable context:</p> <pre><code>@Composable\nfun renderCompose(model: ModelT)\n</code></pre> <p>In practice this is less of a concern, because the <code>render(model)</code> function is deprecated and hidden and callers only see the <code>renderCompose(model)</code> function.</p> <p>Renderers are composable and can build hierarchies similar to <code>Presenters</code>. The parent renderer is responsible for calling <code>render()</code> on the child renderer:</p> <pre><code>data class ParentModel(\n  val childModel: ChildModel\n): BaseModel\n\nclass ParentRenderer(\n  private val childRenderer: ChildRenderer\n): Renderer&lt;ParentModel&gt; {\n  override fun render(model: ParentModel) {\n    childRenderer.render(model.childModel)\n  }\n}\n</code></pre> <p>Note</p> <p>Injecting concrete child <code>Renderers</code> is possible, but less common. More frequently <code>RendererFactory</code> is injected to obtain a <code>Renderer</code> instance for a <code>Model</code>.</p> <p>A <code>Renderer</code> sends events back to the <code>Presenter</code> through the <code>onEvent</code> lambda on a Model.</p> <pre><code>@ContributesRenderer\nclass LoginRenderer : ComposeRenderer&lt;Model&gt;() {\n  @Composable\n  override fun Compose(model: Model) {\n    Button(\n      onClick = { model.onEvent(LoginPresenter.Event.Login(\"Demo\")) },\n    ) {\n      Text(\"Login\")\n    }\n  }\n}\n</code></pre> Sample <p>The sample app implements multiple <code>ComposeRenderers</code>, e.g. <code>LoginRenderer</code>, <code>UserPageListRenderer</code> and <code>UserPageDetailRenderer</code>.</p>"},{"location":"renderer/#rendererfactory","title":"<code>RendererFactory</code>","text":"<p>How <code>Renderers</code> are initialized depends on <code>RendererFactory</code>, which only responsibility is to create and cache <code>Renderers</code> based on the given model. App Platform comes with three different implementations:</p> <code>ComposeRendererFactory</code> <p><code>ComposeRendererFactory</code> is an implementation for Compose Multiplatform and can be used on all supported platforms. It can only create instances of <code>ComposeRenderer</code>.</p> <code>AndroidRendererFactory</code> <p><code>AndroidRendererFactory</code> is only suitable for Android. It can be used to create <code>ViewRenderer</code> instances and its subtypes. It does not support <code>ComposeRenderer</code>. Use <code>ComposeAndroidRendererFactory</code> if you need to mix and match <code>ViewRenderer</code> with <code>ComposeRenderer</code>.</p> <code>ComposeAndroidRendererFactory</code> <p><code>ComposeAndroidRendererFactory</code> is only suitable for Android when using <code>ComposeRenderer</code> together with <code>ViewRenderer</code>. The factory wraps the Renderers for seamless interop.</p>"},{"location":"renderer/#contributesrenderer","title":"<code>@ContributesRenderer</code>","text":"<p>All factory implementations rely on the dependency injection framework <code>kotlin-inject-anvil</code> or Metro to discover and  initialize renderers. When the factory is created, it builds the <code>RendererComponent</code>, which parent is the app component. The <code>RendererComponent</code> lazily provides all renderers using the multibindings feature. To participate in the lookup, renderers must tell <code>kotlin-inject-anvil</code> or Metro which models they can render. This is done through a component  interface, which automatically gets generated and added to the renderer scope by using the <code>@ContributesRenderer</code> annotation.</p> <p>Which <code>Model</code> type is used for the binding is determined based on the super type. In the following example <code>LoginPresenter.Model</code> is used.</p> <pre><code>@ContributesRenderer\nclass LoginRenderer : ComposeRenderer&lt;LoginPresenter.Model&gt;()\n</code></pre> Generated code kotlin-inject-anvilMetro <p>The <code>@ContributesRenderer</code> annotation generates following code.</p> <pre><code>@ContributesTo(RendererScope::class)\ninterface LoginRendererComponent {\n  @Provides\n  public fun provideSoftwareAmazonAppPlatformSampleLoginLoginRenderer(): LoginRenderer = LoginRenderer()\n\n  @Provides\n  @IntoMap\n  public fun provideSoftwareAmazonAppPlatformSampleLoginLoginRendererLoginPresenterModel(renderer: () -&gt; LoginRenderer): Pair&lt;KClass&lt;out BaseModel&gt;, () -&gt; Renderer&lt;*&gt;&gt; = LoginPresenter.Model::class to renderer\n\n  @Provides\n  @IntoMap\n  @ForScope(scope = RendererScope::class)\n  public fun provideSoftwareAmazonAppPlatformSampleLoginLoginRendererLoginPresenterModelKey(): Pair&lt;KClass&lt;out BaseModel&gt;, KClass&lt;out Renderer&lt;*&gt;&gt;&gt; = LoginPresenter.Model::class to LoginRenderer::class\n}\n</code></pre> <p>The <code>@ContributesRenderer</code> annotation generates following code.</p> <pre><code>@ContributesTo(RendererScope::class)\ninterface LoginRendererGraph {\n  @Provides\n  public fun provideSoftwareAmazonAppPlatformSampleLoginLoginRenderer(): LoginRenderer = LoginRenderer()\n\n  @Provides\n  @IntoMap\n  @RendererKey(LoginPresenter.Model::class)\n  public fun provideSoftwareAmazonAppPlatformSampleLoginLoginRendererLoginPresenterModel(renderer: Provider&lt;LoginRenderer&gt;): Renderer&lt;*&gt; = renderer()\n\n  @Provides\n  @IntoMap\n  @ForScope(scope = RendererScope::class)\n  @RendererKey(LoginPresenter.Model::class)\n  public fun provideSoftwareAmazonAppPlatformSampleLoginLoginRendererLoginPresenterModelKey(): KClass&lt;out Renderer&lt;*&gt;&gt; = LoginRenderer::class\n}\n</code></pre>"},{"location":"renderer/#creating-rendererfactory","title":"Creating <code>RendererFactory</code>","text":"<p>The <code>RendererFactory</code> should be created and cached in the platform specific UI context, e.g. an iOS <code>UIViewController</code> or Android <code>Activity</code>.</p> iOS Compose Multiplatform<pre><code>fun mainViewController(rootScopeProvider: RootScopeProvider): UIViewController =\n  ComposeUIViewController {\n    // Only a single factory is needed.\n    val rendererFactory = remember { ComposeRendererFactory(rootScopeProvider) }\n    ...\n  }\n</code></pre> Android Activity<pre><code>class MainActivity : ComponentActivity() {\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n\n    val rendererFactory =\n      ComposeAndroidRendererFactory(\n        rootScopeProvider = application as RootScopeProvider,\n        activity = this,\n        parent = findViewById(R.id.main_container),\n      )\n    ...\n  }\n}\n</code></pre> Sample <p>The sample app uses <code>ComposeAndroidRendererFactory</code> in Android application and <code>ComposeRendererFactory</code> for iOS and Desktop.</p>"},{"location":"renderer/#creating-renderers","title":"Creating <code>Renderers</code>","text":"<p>Based on a <code>Model</code> instance or <code>Model</code> type a <code>RendererFactory</code> can create a new <code>Renderer</code> instance. The <code>getRenderer()</code> function creates a <code>Renderer</code> only once and caches the instance after that. This makes the caller side simpler. Whenever a new <code>Model</code> is available get the <code>Renderer</code> for the <code>Model</code> and render the content on screen.</p> iOS Compose Multiplatform<pre><code>fun mainViewController(rootScopeProvider: RootScopeProvider): UIViewController =\n  ComposeUIViewController {\n    // Only a single factory is needed.\n    val rendererFactory = remember { ComposeRendererFactory(rootScopeProvider) }\n\n    val model = presenter.present(Unit)\n\n    val renderer = factory.getComposeRenderer(model)\n    renderer.renderCompose(model)\n  }\n</code></pre> <p>Note</p> <p>Note that <code>getRenderer()</code> for <code>ComposeRendererFactory</code> returns a <code>ComposeRenderer</code>. For a <code>ComposeRenderer</code> the <code>renderCompose(model)</code> function must be called and not <code>render(model)</code>.</p> Android Activity<pre><code>class MainActivity : ComponentActivity() {\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n\n    val rendererFactory = ComposeAndroidRendererFactory(...)\n    val models: StateFlow&lt;Model&gt; = ...\n    ...\n\n    lifecycleScope.launch {\n      repeatOnLifecycle(Lifecycle.State.STARTED) {\n        models.collect { model -&gt;\n          val renderer = rendererFactory.getRenderer(model)\n          renderer.render(model)\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"renderer/#injecting-rendererfactory","title":"Injecting <code>RendererFactory</code>","text":"<p>The <code>RendererFactory</code> is provided in the <code>RendererComponent</code>, meaning it can be injected by any <code>Renderer</code>. This allows you to create child renderers without knowing the concrete type of the model and injecting the child renderers ahead of time:</p> <pre><code>@Inject\n@ContributesRenderer\nclass SampleRenderer(\n  private val rendererFactory: RendererFactory\n) : ComposeRenderer&lt;Model&gt;() {\n\n  @Composable\n  override fun Compose(model: Model) {\n    val childRenderer = rendererFactory.getComposeRenderer(model.childModel)\n    childRenderer.renderCompose(model.childModel)\n  }\n}\n</code></pre> Sample <p>The sample app injects <code>RendererFactory</code> in <code>ComposeSampleAppTemplateRenderer</code> to create <code>Renderers</code> dynamically for unknown <code>Model</code> types. There is also an Android sample implementation.</p> <p>Note</p> <p>Whenever a <code>Renderer</code> has an injected constructor parameter like <code>rendererFactory</code> in the sample above, then the class must be annotated with <code>@Inject</code> in addition to <code>@ContributesRenderer</code>.</p>"},{"location":"renderer/#android-support","title":"Android support","text":"<p>Android Views are supported out of the box using <code>ViewRenderer</code>.</p>"},{"location":"renderer/#compose-interop","title":"Compose interop","text":"<p>If an Android app uses only Compose UI with <code>ComposeRenderer</code>, then it can use <code>ComposeRendererFactory</code> similar to iOS and Desktop to create <code>ComposeRenderer</code> instances. However, if interop with Android Views is needed, then <code>ComposeAndroidRendererFactory</code> must be used. <code>ComposeAndroidRendererFactory</code> makes it transparent which <code>Renderer</code> implementation is used and interop is seamless. A <code>ComposeRenderer</code> that has a child <code>ViewRenderer</code> wraps the Android view within a <code>AndroidView</code> composable function call. A <code>ViewRenderer</code> that has a child <code>ComposeRenderer</code> wraps the Compose UI within a <code>ComposeView</code> Android View.</p> <pre><code>val rendererFactory = ComposeAndroidRendererFactory(...)\n\nval renderer = rendererFactory.getRenderer(model)\nrender.render(model)\n</code></pre> <p>In this example the returned <code>Renderer</code> can be a <code>ComposeRenderer</code> or <code>ViewRenderer</code>, it would not matter and either the Compose UI or Android Views would be rendered on screen. With the seamless interop it becomes easier to migrate from Android Views to Compose UI by simply migrating renderers one by one.</p>"},{"location":"renderer/#viewrenderer-subtypes","title":"<code>ViewRenderer</code> subtypes","text":"<code>ViewBindingRenderer</code>. <p>View binding is supported out of the box using <code>ViewBindingRenderer</code>.</p> <code>RecyclerViewViewHolderRenderer</code> <p><code>RecyclerViewViewHolderRenderer</code> allows you to implement elements of a <code>RecyclerView</code> as a <code>Renderer</code>.</p>"},{"location":"renderer/#unit-tests","title":"Unit tests","text":"<p><code>ComposeRenderer</code> can easily be tested as unit tests on Desktop and iOS. In particular tests for Desktop are helpful due to the fast build times. Various fake <code>Models</code> can be passed to the <code>Renderer</code> and the UI state based on the model verified.</p> <p>Testing <code>ComposeRenderer</code> or <code>ViewRenderer</code> for Android requires an Android device or emulator.</p> <p>This test runs as a unit test on iOS and Desktop.</p> <pre><code>class LoginRendererTest {\n\n  @Test\n  fun `the login button is rendered when not logging in`() {\n    runComposeUiTest {\n      setContent {\n        val renderer = LoginRenderer()\n        renderer.renderCompose(LoginPresenter.Model(loginInProgress = false) {})\n      }\n\n      onNodeWithTag(\"loginProgress\").assertDoesNotExist()\n      onNodeWithTag(\"loginButton\").assertIsDisplayed()\n    }\n  }\n}\n</code></pre> Sample <p>The sample app demonstrates this with the <code>LoginRendererTest</code>. To avoid duplicating the test in the <code>desktopTest</code> and <code>iosTest</code> source folders, the sample app has a custom source set <code>appleAndDesktop</code>, which is a shared parent source set for <code>apple</code> and <code>desktop</code>.</p>"},{"location":"scope/","title":"Scope","text":"<p>Note</p> <p>Importing the <code>Scopes</code> API is an opt-in feature through the Gradle DSL. The default value is <code>false</code>. <pre><code>appPlatform {\n  addPublicModuleDependencies true\n}\n</code></pre></p>"},{"location":"scope/#overview","title":"Overview","text":"<p>Scopes define the boundary our software components operate in. A scope is a space with a well-defined lifecycle that can be created and torn down. Scopes host other objects and can bind them to their lifecycle. Sub-scopes or child scopes have the same or a shorter lifecycle as their parent scope.</p> <p>A leak happens when one scope references another scope with a different lifecycle, e.g. a background thread, which is started and finishes after a certain amount of time, references an Android <code>Activity</code> that is being destroyed while the thread is still running. In this case the thread with the longer lifecycle leaks the <code>Activity</code> with the shorter lifecycle. Another example is a singleton object, which lives as long as the application process runs, keeping a strong reference to a user object, which should be released after the user session expires.</p> <p>Relying purely on platform specific scopes is problematic, because these scopes are out of our control. When the platform decides to destroy one of its scopes, then we need to adjust and tear down our operations. This doesn\u2019t always align with our use cases, e.g. we might want to finish uploading data in the background after the platform scope such as an <code>Activity</code> has been destroyed. Further, the platform scopes may not align with how we\u2019d represent logical scopes for our apps, e.g. they often lack a user scope. This forces us to push objects and lifecycles into the application scope and this could cause data to leak across sessions and trigger out of memory scenarios.</p> <p>We need to be in charge of our own scopes. In simple terms this means having an object that can be created and destroyed.</p> <p>The App Platform provides the Scope interface to implement this concept.</p> Scope.kt<pre><code>interface Scope {\n\n  val name: String\n  val parent: Scope?\n\n  fun buildChild(name: String, builder: (Builder.() -&gt; Unit)? = null): Scope\n  fun children(): Set&lt;Scope&gt;\n\n  fun isDestroyed(): Boolean\n  fun destroy()\n\n  fun register(scoped: Scoped)\n  fun &lt;T : Any&gt; getService(key: String): T?\n}\n</code></pre>"},{"location":"scope/#creating-a-scope","title":"Creating a <code>Scope</code>","text":"<p>A <code>Scope</code> is created through the builder function. The Builder allows you to add services before the Scope is finalized:</p> <pre><code>val rootScope = Scope.buildRootScope {\n  addService(\"key\", service)\n}\n</code></pre> <p>Child scopes are created using the parent:</p> <pre><code>rootScope.buildChild(\"user scope\") {\n  addService(\"child-service\", childService)\n}\n</code></pre> Sample <p>The root scope is usually created when the application is launched. The sample application creates its root scope here. This <code>Scope</code> is never destroyed and stays alive for the entire app lifetime.</p> <p>The sample application has a child scope for the logged in user. This <code>Scope</code> is created during login and destroyed during logout.</p> <pre><code>override fun login(userId: Long) {\n  ...\n  val userComponent = userComponentFactory.createUserComponent(user)\n\n  val userScope =\n    rootScopeProvider.rootScope.buildChild(\"user-$userId\") {\n      addKotlinInjectComponent(userComponent)\n      addCoroutineScopeScoped(userComponent.userScopeCoroutineScopeScoped)\n    }\n\n  ...\n\n  userScope.register(userComponent.userScopedInstances)\n}\n\noverride fun logout() {\n  val currentUserScope = user.value?.scope\n  ...\n  currentUserScope?.destroy()\n}\n</code></pre> <p>Tests usually leverage the test scope, which comes with better defaults for services such as the coroutine scope:</p> <pre><code>@Test\nfun `my test`() = runTest {\n  val scope = Scope.buildTestScope(this)\n}\n\n// Or\n@Test\nfun `my test`() = runTestWithScope { scope -&gt;\n  // `scope` is equivalent to calling `Scope.buildTestScope(this)`.\n}\n</code></pre> Sample <p>Classes implementing the <code>Scoped</code> interface usually make use of the <code>runTestWithScope</code> function in their tests. Notice in this sample how <code>SessionTimeout</code>, which implements the <code>Scoped</code> interface, is registered in the <code>Scope</code>.</p> <pre><code>@Test\nfun `on timeout the user is logged out`() = runTestWithScope { scope -&gt;\n  val userManager = FakeUserManager()\n  userManager.login(1L)\n\n  val sessionTimeout = SessionTimeout(userManager, FakeAnimationHelper)\n  scope.register(sessionTimeout)\n\n  assertThat(userManager.user.value).isNotNull()\n\n  advanceTimeBy(SessionTimeout.initialTimeout + 1.milliseconds)\n  assertThat(userManager.user.value).isNull()\n}\n</code></pre>"},{"location":"scope/#services","title":"Services","text":"<p>A scope can host other objects like an object graph from dependency injection frameworks and a coroutine scope. The latter is especially helpful, because the coroutine scope can be canceled when our logical scope is destroyed and all pending operations are torn down. Connecting our scopes with the dependency injection components makes our dependency injection setup more flexible, because we\u2019re in charge of instantiating components and can provide extra objects like a user ID to the object graph. When a scope is destroyed we release the dependency injection component and the memory can be reclaimed by the runtime. DI components and subcomponents form a tree, therefore subcomponents can inject all types that are provided by parent components. The strong recommendation is to align the component tree with the scope hierarchy.</p> <p>While a service can be obtained through the <code>getService()</code> function, a more frequent pattern is to rely on extension functions for stronger types. Similarly, an extension function on the <code>Builder</code> allows us to add a service to a <code>Scope</code>.</p> <pre><code>interface MyService\n\nprivate const val MY_SERVICE_KEY = \"myService\"\n\nfun Scope.Builder.addMyService(service: MyService) {\n  addService(MY_SERVICE_KEY, service)\n}\n\nfun Scope.myService(): MyService {\n  return checkNotNull(getService&lt;MyService&gt;(MY_SERVICE_KEY))\n}\n</code></pre> <p>The App Platform comes with a coroutine scope service and an integration for kotlin-inject-anvil and Metro  as dependency injection frameworks.</p> <pre><code>val rootScope = Scope.buildRootScope {\n  addCoroutineScopeScoped(coroutineScope)\n  addKotlinInjectComponent(kotlinInjectComponent)\n  addMetroDependencyGraph(metroDependencyGraph)\n}\n\n// Obtain service.\nrootScope.coroutineScope()\nrootScope.kotlinInjectComponent&lt;AbcComponent&gt;()\nrootScope.metroDependencyGraph&lt;DefGraph&gt;()\n</code></pre> <p>Warning</p> <p><code>Scopes</code> through their service mechanism implement the service locator pattern. With the provided dependency injection framework usually it\u2019s not needed to add custom services and it\u2019s better to rely on dependency injection instead.</p>"},{"location":"scope/#coroutinescope","title":"<code>CoroutineScope</code>","text":"<p>Info</p> <p>By default, the IO dispatcher is used for all launched jobs for the provided <code>CoroutineScope</code>.</p> <p>In tests when using <code>Scope.buildTestScope()</code> or <code>runTestWithScope</code> the <code>backgroundScope</code> is from the <code>TestScope</code> is used by default and added to <code>Scope</code> instance.</p> <p>It\u2019s strongly recommended to add a <code>CoroutineScope</code> to each <code>Scope</code>. App Platform provides a <code>CoroutineScope</code> by default for the <code>AppScope</code>. It is important to register this <code>CoroutineScope</code> in the created app <code>Scope</code> instance in order to cancel the <code>CoroutineScope</code> in case the <code>AppScope</code> ever gets destroyed. The same applies to any child scope.</p> kotlin-inject-anvilMetro <pre><code>@SingleIn(AppScope::class)\n@MergeComponent(AppScope::class)\ninterface AppComponent {\n  /** The coroutine scope that runs as long as the app scope is alive. */\n  @ForScope(AppScope::class) val appScopeCoroutineScopeScoped: CoroutineScopeScoped // (1)!\n}\n\nfun createAppScope(appComponent: AppComponent): Scope {\n  return Scope.buildRootScope {\n    addKotlinInjectComponent(appComponent)\n    addCoroutineScopeScoped(appComponent.appScopeCoroutineScopeScoped)\n  }\n}\n</code></pre> <ol> <li><code>CoroutineScopeScoped</code> wraps a <code>CoroutineScope</code> in a <code>Scoped</code> instance. In <code>onExitScope()</code> of this instance the     <code>CoroutineScope</code> will be canceled.</li> </ol> <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  /** The coroutine scope that runs as long as the app scope is alive. */\n  @ForScope(AppScope::class) val appScopeCoroutineScopeScoped: CoroutineScopeScoped // (1)!\n}\n\nfun createAppScope(appGraph: AppGraph): Scope {\n  return Scope.buildRootScope {\n    addMetroDependencyGraph(appGraph)\n    addCoroutineScopeScoped(appGraph.appScopeCoroutineScopeScoped)\n  }\n}\n</code></pre> <ol> <li><code>CoroutineScopeScoped</code> wraps a <code>CoroutineScope</code> in a <code>Scoped</code> instance. In <code>onExitScope()</code> of this instance the     <code>CoroutineScope</code> will be canceled.</li> </ol> <p>The <code>CoroutineScope</code> can be injected in classes and used to launch async work. A common pattern is to use the <code>onEnterScope()</code> function when implementing the <code>Scoped</code> interface to launch coroutine jobs:</p> <pre><code>override fun onEnterScope(scope: Scope) {\n  // This job will be automatically canceled when the `scope` gets destroyed.\n  scope.launch { // (1)!\n    someFlow.collect {\n      ...\n    }\n  }\n}\n</code></pre> <ol> <li><code>scope.launch</code> is a convenience function for <code>scope.coroutineScope().launch</code>.</li> </ol> <p>Since the <code>CoroutineScope</code> is part of the <code>kotlin-inject-anvil</code> or Metro object graph, the <code>CoroutineScope</code> can be injected in the constructor as well:</p> <pre><code>@Inject\n@SingleIn(AppScope::class)\nclass MyClass(@ForScope(AppScope::class) coroutineScope: CoroutineScope) {\n  init {\n    coroutineScope.launch {\n      ...\n    }\n  }\n}\n</code></pre> <p>Whenever a <code>CoroutineScope</code> is injected, a new child <code>CoroutineScope</code> with its own <code>Job</code> is created (the parent <code>Job</code> points to the shared <code>CoroutineScope</code> <code>Job</code>). The prevents consumers from accidentally tearing down all running coroutines when canceling an injected <code>CoroutineScope</code>.</p> <pre><code>override fun onEnterScope(scope: Scope) {\n  val myCoroutineScope = scope.coroutineScope()\n\n  myCoroutineScope.launch { ... }\n  myCoroutineScope.launch { ... }\n\n  // This is safe to do and only cancels the two launched jobs and `myCoroutineScope`. It doesn't cancel the\n  // shared `CoroutineScope` hosted within the `scope` object.\n  myCoroutineScope.cancel()\n}\n</code></pre>"},{"location":"scope/#scoped","title":"<code>Scoped</code>","text":"<p>Service objects can tie themselves to the lifecycle of a scope by implementing the <code>Scoped</code> interface:</p> <pre><code>interface Scoped {\n    fun onEnterScope(scope: Scope)\n    fun onExitScope()\n}\n</code></pre> <p>Usually, we rely on our dependency injection framework to instantiate all <code>Scoped</code> instances for a scope. By doing so service objects will be automatically created when their corresponding scope is created and receive a callback when their scope is destroyed. This helps with loose coupling between our service objects. Implementing the <code>Scoped</code> interface is a detail, which doesn\u2019t need to be exposed to the API layer:</p> <pre><code>interface LocationProvider {\n  val location: StateFlow&lt;Location&gt;\n}\n\nclass AndroidLocationProvider(\n  private val locationManager: LocationManager\n) : LocationProvider, Scoped {\n\n  private val _location = MutableStateFlow&lt;Location&gt;()\n  override val location get() = _location\n\n  override fun onEnterScope(scope: Scope) {\n    scope.launch {\n      // Observe location updates through LocationManager\n\n      val androidLocation = ...\n      _location.value = androidLocation\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>Note in the example that the concrete implementation class implements the <code>Scoped</code> interface and not <code>LocationProvider</code>. Being lifecycle aware is an implementation detail.</p> <p>How the <code>Scoped</code> object is instantiated depends on the dependency injection framework and which scope to use. With <code>kotlin-inject-anvil</code> and Metro for the app scope it would be:</p> kotlin-inject-anvilMetro <pre><code>@Inject // (1)!\n@SingleIn(AppScope::class) // (2)!\n@ContributesBinding(AppScope::class) //(3)!\nclass AndroidLocationProvider(\n  ...\n) : LocationProvider, Scoped {\n  ...\n}\n</code></pre> <ol> <li>This annotation is required to support constructor injection.</li> <li>This annotation ensures that there is only ever a single instance of <code>AndroidLocationProvider</code> in the <code>AppScope</code>.</li> <li>This annotation ensures that when somebody injects <code>LocationProvider</code>, then they get the singleton instance of <code>AndroidLocationProvider</code>.</li> </ol> <code>@ContributesBinding</code> will generate and contribute bindings <p>The <code>@ContributesBinding</code> annotation will generate a component interface with bindings for <code>LocationProvider</code> and <code>Scoped</code>. The generated interface will be added automatically to the <code>AppScope</code>. No further manual step is needed.</p> <pre><code>@Provides\npublic fun provideAndroidLocationProvider(androidLocationProvider: AndroidLocationProvider): LocationProvider = androidLocationProvider\n\n@Provides\n@IntoSet\n@ForScope(AppScope::class)\nfun provideAndroidLocationProviderScoped(androidLocationProvider: AndroidLocationProvider): Scoped = androidLocationProvider\n</code></pre> <pre><code>@Inject // (1)!\n@SingleIn(AppScope::class) // (2)!\n@ContributesScoped(AppScope::class) //(3)!\nclass AndroidLocationProvider(\n  ...\n) : LocationProvider, Scoped {\n  ...\n}\n</code></pre> <ol> <li>This annotation is required to support constructor injection.</li> <li>This annotation ensures that there is only ever a single instance of <code>AndroidLocationProvider</code> in the <code>AppScope</code>.</li> <li>This annotation ensures that when somebody injects <code>LocationProvider</code>, then they get the singleton instance of <code>AndroidLocationProvider</code>.</li> </ol> <code>@ContributesScoped</code> will generate and contribute bindings <p>The <code>@ContributesScoped</code> annotation will generate a graph interface with bindings for <code>LocationProvider</code> and <code>Scoped</code>. The generated interface will be added automatically to the <code>AppScope</code>. No further manual step is needed.</p> <pre><code>@Binds\nval AndroidLocationProvider.binds: LocationProvider\n\n@Binds @IntoSet @ForScope(AppScope::class)\nval AndroidLocationProvider.bindsScoped: Scoped\n</code></pre> Sample <p>Another example in the sample app is <code>SessionTimeout</code>. This class is part of the <code>UserScope</code> and implements the <code>Scoped</code> interface. <code>onEnterScope()</code> will be called when the user logs in and <code>onExitScope()</code> when the user logs out.</p> <pre><code>@Inject\n@SingleIn(UserScope::class)\n@ContributesBinding(UserScope::class) // Use @ContributesScoped with Metro.\nclass SessionTimeout(...) : Scoped {\n\n  override fun onEnterScope(scope: Scope) {\n    // This job will be automatically canceled when the user logs out and the user scope is\n    // destroyed.\n    scope.launch {\n      while (userManager.user.value != null) {\n        ...\n      }\n    }\n\n    scope.launch {\n      ...\n    }\n  }\n}\n</code></pre>"},{"location":"scope/#registering-scoped","title":"Registering <code>Scoped</code>","text":"<p>The dependency injection frameworks like <code>kotlin-inject-anvil</code> and Metro are only responsible for creating <code>Scoped</code>  instances, but don\u2019t automatically register them in the <code>Scope</code>. This has to be done whenever the <code>Scope</code> is created:</p> kotlin-inject-anvilMetro <pre><code>@SingleIn(AppScope::class)\n@MergeComponent(AppScope::class)\ninterface AppComponent {\n  /** All [Scoped] instances part of the app scope. */\n  @ForScope(AppScope::class) val appScopedInstances: Set&lt;Scoped&gt;\n}\n\nfun createAppScope(appComponent: AppComponent): Scope {\n  val rootScope =\n    Scope.buildRootScope {\n      addKotlinInjectComponent(appComponent)\n\n      addCoroutineScopeScoped(appComponent.appScopeCoroutineScopeScoped)\n    }\n\n  rootScope.register(appComponent.appScopedInstances)\n\n  return rootScope\n}\n</code></pre> <p>By calling <code>appComponent.appScopedInstances</code> the DI framework instantiates all <code>Scoped</code> instances part of the <code>AppScope</code>. The <code>rootScope.register(...)</code> call will register all of the <code>Scoped</code> instances and invoke <code>onEnterScope(scope)</code>. When calling <code>rootScope.destroy()</code> later at some point, then <code>onExitScope()</code> will be called for all <code>Scoped</code> instances.</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  /** All [Scoped] instances part of the app scope. */\n  @ForScope(AppScope::class) val appScopedInstances: Set&lt;Scoped&gt;\n}\n\nfun createAppScope(appGraph: AppGraph): Scope {\n  val rootScope =\n    Scope.buildRootScope {\n      addMetroDependencyGraph(appGraph)\n\n      addCoroutineScopeScoped(appGraph.appScopeCoroutineScopeScoped)\n    }\n\n  rootScope.register(appGraph.appScopedInstances)\n\n  return rootScope\n}\n</code></pre> <p>By calling <code>appGraph.appScopedInstances</code> the DI framework instantiates all <code>Scoped</code> instances part of the <code>AppScope</code>. The <code>rootScope.register(...)</code> call will register all of the <code>Scoped</code> instances and invoke <code>onEnterScope(scope)</code>. When calling <code>rootScope.destroy()</code> later at some point, then <code>onExitScope()</code> will be called for all <code>Scoped</code> instances.</p> Sample <p>The sample application implements this mechanism for the <code>AppScope</code> and the <code>UserScope</code>.</p>"},{"location":"scope/#onexit","title":"<code>onExit</code>","text":"<p>The convenience function <code>onExit</code> is handy when you want to create objects lazily within <code>onEnterScope()</code> and not create a property in the class itself. This callback notifies you when the <code>Scope</code> is destroyed similar to <code>onExitScope()</code>.</p> kotlin-inject-anvilMetro <pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesBinding(AppScope::class)\nclass MyClass(private val application: Application) : Scoped {\n\n  override fun onEnterScope(scope: Scope) {\n    val receiver = object : BroadcastReceiver()\n\n    application.registerReceiver(receiver, Intent())\n\n    scope.onExit {\n      // This function is invoked when the scope gets destroyed.\n      application.unregisterReceiver(receiver)\n    }\n  }\n}\n</code></pre> <pre><code>@Inject\n@SingleIn(AppScope::class)\n@ContributesScoped(AppScope::class)\nclass MyClass(private val application: Application) : Scoped {\n\n  override fun onEnterScope(scope: Scope) {\n    val receiver = object : BroadcastReceiver()\n\n    application.registerReceiver(receiver, Intent())\n\n    scope.onExit {\n      // This function is invoked when the scope gets destroyed.\n      application.unregisterReceiver(receiver)\n    }\n  }\n}\n</code></pre>"},{"location":"scope/#threading","title":"Threading","text":"<p>Which thread is used for calling <code>onEnterScope()</code> and <code>onExitScope()</code> is an implementation detail of the scope owner when calling <code>scope.register(Scoped)</code>. Usually, the app scope is created as soon as possible when the application launches and therefore the main thread is used. Child scopes may use the main thread or a background thread.</p> <p>To safely launch long running work or blocking tasks it\u2019s recommended to use the coroutine scope provided by the <code>Scope</code>:</p> <pre><code>override fun onEnterScope(scope: Scope) {\n  scope.launch { ... }\n}\n</code></pre> <p>Clean up routines in <code>onExitScope()</code> must be blocking, otherwise these tasks live longer than the <code>Scope</code> and therefore may cause a leak (thread and memory) and potential race conditions. It\u2019s strongly recommended not to launch any asynchronous work within <code>onExitScope()</code>. By the time <code>onExitScope()</code> is called, the coroutine scope provided by the <code>Scope</code> has been canceled already.</p>"},{"location":"scope/#hosting-scopes","title":"Hosting <code>Scopes</code>","text":"<p>Scopes need to be remembered and must be accessible in order to get access to their services. Where to host scopes depends on what scopes are required and when they need to be created. Most apps have some form of an application scope, which is a singleton scope for the entire lifetime of the application. A natural place to host this scope for Android apps is within the <code>Application</code> class, for iOS apps within <code>App</code> struct or the main function for desktop applications.</p> <p>A user scope has a shorter lifecycle than the application scope, but usually lives longer than UI components. It is commonly hosted by a service object managing the login state. This scope is destroyed after the user session expires.</p> <p>App Platform by default only provides the <code>AppScope</code>, which has to be manually created by each application as highlighted above.</p> Sample <p>The sample application has a common class DemoApplication that is responsible for creating the app scope. The Android app instantiates <code>DemoApplication</code> in the <code>Application</code> class. The iOS sample creates the <code>DemoApplication</code> in the <code>UIApplicationDelegate</code>. On Desktop <code>DemoApplication</code> is created part of the <code>main()</code> function.</p>"},{"location":"scope/#rootscopeprovider","title":"<code>RootScopeProvider</code>","text":"<p><code>RootScopeProvider</code>, as the name suggests, gives access to the root <code>Scope</code> (\u201cAppScope\u201d). Usually, this interface is implemented by the application object of the individual platform to get access to the root <code>Scope</code> from a platform context, e.g. on Android this is handy in an <code>Activity</code>:</p> <pre><code>class MainActivity : Activity() {\n\n  private val rootScopeProvider\n    get() = application as RootScopeProvider\n\n  ...\n}\n</code></pre> Sample <p>The sample application implements <code>RootScopeProvider</code> in the Android <code>Application</code> class and the iOS <code>UIApplicationDelegate</code>. On Desktop there is no concept of a singleton application object by default, but in the sample app we created an equivalent with <code>DesktopApp</code>.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#gradle","title":"Gradle","text":"<p>App Platform, its various features and dependencies are all configured through a Gradle plugin. The various options are explained in more detail in many of the following sections.</p> build.gradlebuild.gradle.kts <pre><code>plugins {\n  id 'software.amazon.app.platform' version 'x.y.z'\n}\n\nappPlatform {\n  // false by default. Adds dependencies on the APIs for scopes, presenters and renderers in order to use the App Platform.\n  addPublicModuleDependencies true\n\n  // false by default. Helpful for final application modules that must consume concrete implementations and not only APIs.\n  addImplModuleDependencies true\n\n  // false by default. Configures KSP and adds the kotlin-inject-anvil library as dependency.\n  enableKotlinInject true\n\n  // false by default. Configures Metro and adds App Platform specific extensions as dependency.\n  enableMetro true\n\n  // false by default. Configures Molecule and provides access to the MoleculePresenter API.\n  enableMoleculePresenters true\n\n  // false by default. Adds the necessary dependencies to use Compose Multiplatform with Renderers.\n  enableComposeUi true\n\n  // false by default. Verifies that this module follows conventions for our module structure and\n  // adds default dependencies. For Android projects it sets the namespace to avoid conflicts.\n  enableModuleStructure true\n}\n</code></pre> <pre><code>plugins {\n  id(\"software.amazon.app.platform\") version \"x.y.z\"\n}\n\nappPlatform {\n  // false by default. Adds dependencies on the APIs for scopes, presenters and renderers in order to use the App Platform.\n  addPublicModuleDependencies(true)\n\n  // false by default. Helpful for final application modules that must consume concrete implementations and not only APIs.\n  addImplModuleDependencies(true)\n\n  // false by default. Configures KSP and adds the kotlin-inject-anvil library as dependency.\n  enableKotlinInject(true)\n\n  // false by default. Configures Metro and adds App Platform specific extensions as dependency.\n  enableMetro(true)\n\n  // false by default. Configures Molecule and provides access to the MoleculePresenter API.\n  enableMoleculePresenters(true)\n\n  // false by default. Adds the necessary dependencies to use Compose Multiplatform with Renderers.\n  enableComposeUi(true)\n\n  // false by default. Verifies that this module follows conventions for our module structure and\n  // adds default dependencies. For Android projects it sets the namespace to avoid conflicts.\n  enableModuleStructure(true)\n}\n</code></pre> <p>Note</p> <p>All settings of App Platform are optional and opt-in, e.g. you can use Molecule Presenters without enabling the opinionated module structure. Compose UI can be enabled without using <code>kotlin-inject-anvil</code> or <code>Metro</code>.</p>"},{"location":"setup/#snapshot","title":"Snapshot","text":"<p>To import snapshot builds use following repository:</p> build.gradlebuild.gradle.kts <pre><code>maven {\n  url = 'https://central.sonatype.com/repository/maven-snapshots/'\n}\n</code></pre> <pre><code>maven {\n  url = uri(\"https://central.sonatype.com/repository/maven-snapshots/\")\n}\n</code></pre>"},{"location":"template/","title":"Template","text":"<p><code>Templates</code> are an abstraction between <code>Presenters</code> and <code>Renderers</code> and represent the root of the presenter and renderer tree. Practically, a template is one particular type of <code>BaseModel</code> that hosts other models (a container of models). However, instead of using a weak type like <code>List&lt;BaseModel&gt;</code>, a template carries semantics about what content should be rendered, how many UI layers there are and where each individual model should be displayed.</p> <p><code>Templates</code> are app specific and not shared, because each app may use a different layering mechanism for individual screen configurations. An example template definition could look like this:</p> <pre><code>sealed interface SampleAppTemplate : Template {\n\n  data class FullScreenTemplate(\n    val model: BaseModel,\n  ) : SampleAppTemplate\n\n  data class ListDetailTemplate(\n    val list: BaseModel,\n    val detail: BaseModel,\n  ) : SampleAppTemplate\n}\n</code></pre> Sample <p>A similar hierarchy is implemented in the sample application.</p> <p>The <code>Template</code> interface extends <code>BaseModel</code> and each app must come with its own <code>TemplatePresenter</code> and <code>TemplateRenderer</code>. Both are implemented the same way as other presenters and renderers would be implemented. The responsibility of the <code>TemplatePresenter</code> is to wrap another presenter and wrap its models within a <code>Template</code>, e.g.</p> <pre><code>@Inject\nclass SampleAppTemplatePresenter(\n  @Assisted private val rootPresenter: MoleculePresenter&lt;Unit, *&gt;,\n) : MoleculePresenter&lt;Unit, SampleAppTemplate&gt; {\n  @Composable\n  override fun present(input: Unit): SampleAppTemplate {\n    return returningCompositionLocalProvider {\n      rootPresenter.present(Unit).toTemplate {\n        SampleAppTemplate.FullScreenTemplate(it)\n      }\n    }\n  }\n}\n</code></pre> Sample <p>The sample app has a similar implementation.</p> <p>The wrapped presenter can override which <code>Template</code> to use by implementing <code>ModelDelegate</code>, e.g.</p> <pre><code>data class Model(\n  ...\n) : BaseModel, ModelDelegate {\n  override fun delegate(): BaseModel = ListDetailTemplate(...)\n}\n</code></pre> Sample <p>The sample app makes use of this mechanism in the user page, where it the layout is split between a list presenter / renderer and detail presenter / renderer.</p> <pre><code>data class Model(\n  val listModel: BaseModel,\n  val detailModel: BaseModel\n) : BaseModel, ModelDelegate {\n  override fun delegate(): BaseModel {\n    return SampleAppTemplate.ListDetailTemplate(listModel, detailModel)\n  }\n}\n</code></pre> <p>The <code>TemplateRenderer</code> receives the specific <code>Template</code>, lays out necessary containers and renders individual models in these layers. The renderer often injects <code>RendererFactory</code> to create renderers for the models, e.g.</p> <pre><code>@Inject\n@ContributesRenderer\nclass ComposeSampleAppTemplateRenderer(\n  private val rendererFactory: RendererFactory\n) : ComposeRenderer&lt;SampleAppTemplate&gt;() {\n\n  @Composable\n  override fun Compose(model: SampleAppTemplate) {\n    when (model) {\n      is SampleAppTemplate.FullScreenTemplate -&gt; FullScreen(model)\n      is SampleAppTemplate.ListDetailTemplate -&gt; ListDetail(model)\n    }\n  }\n\n  @Composable\n  private fun FullScreen(template: SampleAppTemplate.FullScreenTemplate) {\n    val renderer = rendererFactory.getComposeRenderer(template.model)\n    renderer.renderCompose(template.model)\n  }\n\n  @Composable\n  private fun ListDetail(template: SampleAppTemplate.ListDetailTemplate) {\n    Row {\n      Column {\n        rendererFactory.getComposeRenderer(template.list).renderCompose(template.list)\n      }\n      Column {\n        rendererFactory.getComposeRenderer(template.detail).renderCompose(template.detail)\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"template/#consuming-templates","title":"Consuming <code>Templates</code>","text":"<p>On the API level <code>Templates</code> are regular <code>Models</code>, with a regular <code>Presenter</code> and <code>Renderer</code>. Therefore, they require no special treatment and the regular <code>RendererFactory</code> can be used:</p> <pre><code>fun mainViewController(rootScopeProvider: RootScopeProvider): UIViewController =\n  ComposeUIViewController {\n    val factory = remember { ComposeRendererFactory(rootScopeProvider = rootScopeProvider) }\n\n    val templatePresenter = remember {\n      val component = rootScopeProvider.rootScope.kotlinInjectComponent&lt;ViewControllerComponent&gt;()\n      component.factory.createSampleAppTemplatePresenter(component.navigationPresenter)\n    }\n\n    val template = templatePresenter.present(Unit)\n    factory.getComposeRenderer(template).renderCompose(template)\n  }\n\n@ContributesTo(AppScope::class)\ninterface ViewControllerComponent {\n  val factory: SampleAppTemplatePresenter.Factory\n  val navigationPresenter: NavigationPresenter\n}\n</code></pre>"},{"location":"template/#unidirectional-dataflow","title":"Unidirectional dataflow","text":"<p>Templates complete the circle in our unidirectional dataflow pattern:</p> <p></p> <p>This diagram summarizes how models from child presenters bubble up ultimately to the template presenter. The template presenter wraps the models in a template, which is then handed off the rendering pipeline. <code>RendererFactory</code> finds the right renderers for the template and models and the content will be shown on screen by individual renderers. The circle repeats either when a renderer invokes a callback from the model and sends the event back to the presenter or another state change occurs within the the presenter tree.</p>"},{"location":"testing/","title":"Testing","text":"<p>A fundamental design pattern to make testing effective is dependency inversion, which means that high-level APIs don\u2019t depend on low-level details and low-level details only import other high-level APIs. It significantly reduces coupling between components.</p> <p>App Platform implements the pattern in its module structure and in Kotlin code. By relying on dependency inversion, we decouple projects from their dependencies and enable testing in isolation. This approach is important for unit tests, instrumented tested and integration tests. These three types of tests rely on a chain of trust, where we assume that dependencies are functioning and tests don\u2019t need to be repeated.</p> <p></p> <p>Instrumented tests</p> <p>The sample application implements instrumented tests for two screens and navigates between the tests. The tests for Desktop highlight how templates are rendered and robots are used for verification. It also sets up a <code>kotlin-inject-anvil</code> <code>TestAppComponent</code>, which replaces the main <code>AppComponent</code>.</p> <p>The same UI test is implemented for Android. The Android tests reuse the same robots for verification and set up a <code>TestAppComponent</code> in a similar way.</p>"},{"location":"testing/#fakes","title":"Fakes","text":"<p>Unit tests build the foundation of the testing pyramid. They verify the smallest components of our app, which usually are single classes or functions and we rarely test multiple classes in combination. Dependencies of these classes are typically replaced by fakes. Due to this low coupling unit tests tend to be very stable.</p> <p>Fakes vs real implementations</p> <p>Using real implementations of dependencies for the unit under test is a valid option as it brings the tested code close to production, increases confidence and removes isolation. A best practice from Google is summarized as:</p> <p>A real implementation is preferred if it is fast, deterministic, and has simple dependencies. For example, a real implementation should be used for a value object. Examples include an amount of money, a date, a geographical address, or a collection class such as a list or a map.</p> <p>However, for more complex code, using a real implementation often isn\u2019t feasible. There might not be an exact answer on when to use a real implementation or a test double given that there are trade-offs to be made.</p> <p>The trade-offs include execution time, determinism and dependency construction. Fakes improve all three points by avoiding slow IO, returning stable results and breaking dependency chains at the cost of diverging from the behavior in production and reduced confidence.</p> <pre><code>interface LocationProvider {\n  val location: StateFlow&lt;Location&gt;\n}\n\nclass RoutingRepository(\n  private val locationProvider: LocationProvider\n)\n</code></pre> <p>Imagine to test <code>RoutingRepository</code>. To create an new instance under test, we must provide a <code>LocationProvider</code>. Since we use dependency inversion and didn\u2019t hardcode a concrete implementation, it is simple to implement a fake for this interface:</p> <pre><code>class FakeLocationProvider(\n  val currentLocation: Location = Location(..)\n) : LocationProvider {\n  private val _location = MutableStateFlow(currentLocation)\n  override val location = _location\n\n  fun updateLocation(newLocation: Location) {\n    _location.value = newLocation\n  }\n}\n</code></pre> <p>Now we can instantiate our <code>RoutingRepository</code>:</p> <pre><code>@Test\nfun `the route is updated when the driver doesn't follow directions`() {\n  val locationProvider = FakeLocationProvider()\n  val routingRepository = RoutingRepository(locationProvider)\n\n  locationProvider.updateLocation(...)\n}\n</code></pre> <p>Good fake implementations are valuable. It\u2019s best practice and strongly encouraged as an API provider to implement fakes for APIs and share them with consumers. The App Platform module structure provides <code>:testing</code> modules for this purpose. For example, the owner of <code>LocationProvider</code> is encouraged to use this structure:</p> <pre><code>:location-provider:public   src/commonMain/kotlin/.../LocationProvider.kt\n:location-provider:testing  src/commonMain/kotlin/.../FakeLocationProvider.kt\n</code></pre> <p>The owner of <code>RoutingRepository</code> can import <code>:location-provider:testing</code> and reuse the provided fake in tests. This avoids duplication.</p> Sample <p>The sample app uses <code>:testing</code> modules to implement and share fakes across modules, e.g. <code>:sample:user:testing</code>. In other modules fakes are created next to the tests ad-hoc, e.g. <code>FakeUserPagePresenter</code> and <code>FakeAnimationHelper</code>.</p> <pre><code>private class FakeUserPagePresenter : UserPagePresenter {\n  @Composable\n  override fun present(input: Unit): UserPagePresenter.Model =\n    UserPagePresenter.Model(\n      listModel = object : BaseModel {},\n      detailModel = object : BaseModel {},\n    )\n}\n</code></pre> <pre><code>object FakeAnimationHelper : AnimationHelper {\n  override fun isAnimationsEnabled(): Boolean = true\n}\n</code></pre>"},{"location":"testing/#robots","title":"Robots","text":"<p>Test <code>Robots</code> are an abstraction between test interactions and the underlying implementation. Imagine several tests clicking the Logout button use the label to find the UI element on the screen. If the copy changes from Logout to Sign out, then all these tests would need to be updated. That is tedious and makes tests harder to maintain. A test robot would hide how the Logout button can be found on screen and only provides an option for the necessary interaction:</p> <pre><code>class LogoutRobot : Robot {\n  fun clickLogoutButton() { .. }\n}\n</code></pre> <p>Test <code>Robots</code> are not limited to UI interactions such as verifying UI elements are shown or hidden and invoking actions on them. They can also be used to change fake implementations or make assertions on them. Imagine a robot toggling network connectivity. Tests do not interact with fake implementations directly similar to them not interacting with UI elements directly.</p> <pre><code>class NetworkRobot : Robot {\n  var networkEnabled: Boolean\n  var connectivity: Connectivity\n\n  var throwErrorOnSendingRequest: Boolean = false\n\n  enum class Connectivity {\n    LTE, 3G, WIFI, ...\n  }\n}\n</code></pre> <p>Another use case is verifying metrics and analytics events. In instrumented tests we\u2019d use a fake metrics implementation rather than sending events to our backend system. The robot would interact with the fake implementation and make assertions:</p> <pre><code>class FakeMetricsService : MetricsService {\n  val metrics: List&lt;Metric&gt;\n}\n\nclass MetricsRobot : Robot {\n  private val service: FakeMetricsService ...\n\n  fun assertMetricTracked(metric: Metric) {\n    assertThat(service.metrics).contains(metric)\n  }\n}\n</code></pre> <p>Fake implementations and test robots help verifying interactions with hardware or devices that are not available during an instrumented test run. For example, interactions with other devices can be simulated using a fake connection.</p> <pre><code>interface WebSocketConnection {\n  suspend fun send(message: ByteArray)\n}\n\nclass FakeWebSocketConnection : WebSocketConnection {\n  var throwError: Boolean\n\n  override suspend fun send(message: ByteArray) {\n    if (throwError) {\n      throw Exception(\"...\"\n    } else {\n      trackMessage(message)\n    }\n  }\n}\n\nclass ConnectionRobot : Robot {\n  private val webSocketConnection: FakeWebSocketConnection\n\n  fun sendingMessageFails() {\n    webSocketConnection.throwError = true\n  }\n\n  fun sendingMessageSucceeds() {\n    webSocketConnection.throwError = false\n  }\n}\n</code></pre>"},{"location":"testing/#robot-types","title":"Robot types","text":"<code>Robot</code>. <p>Use this common interface for robots that don\u2019t interact with any UI, whether that\u2019s Compose Multiplatform or Android Views. To obtain an instance of such a robot use the <code>robot&lt;Type&gt;()</code> function:</p> <pre><code>@Inject\n@ContributesRobot(AppScope::class)\nclass MetricsRobot(\n  private val metricsService: FakeMetricsService\n) : Robot {\n  fun assertMetricTracked(metric: Metric) {\n    assertThat(metricsService.metrics).contains(metric)\n  }\n}\n\n@Test\nfun verify_analytics_event_tracked() {\n  ...\n  robot&lt;MetricsRobot&gt;().assertMetricTracked(..)\n}\n</code></pre> <code>ComposeRobot</code> <p><code>ComposeRobot</code> should be used as parent type when the robot interacts with Compose UI elements. These robots need access to a <code>SemanticsNodeInteractionsProvider</code> instance, which is for example provided by calling <code>runComposeUiTest { ... }</code> within a test. To forward the <code>SemanticsNodeInteractionsProvider</code> instance to the robot call <code>composeRobot&lt;Type&gt;()</code> instead of <code>robot&lt;Type&gt;()</code>.</p> <p>Warning</p> <p>Calling <code>robot&lt;Type&gt;()</code> for a <code>ComposeRobot</code> will result in a crash. Always use <code>composeRobot&lt;Type&gt;()</code> instead.</p> <pre><code>@ContributesRobot(AppScope::class)\nclass LoginRobot : ComposeRobot() {\n\n  private val loginButtonNode\n    get() = compose.onNodeWithTag(\"loginButton\")\n\n  /** Verify that login button is displayed. */\n  fun seeLoginButton() {\n    loginButtonNode.assertIsDisplayed()\n  }\n\n  /** Clicks the login button and starts the login process. */\n  fun clickLoginButton() {\n    loginButtonNode.performClick()\n  }\n}\n\n@Test\nfun `sample test`() {\n  runComposeUiTest {\n    composeRobot&lt;LoginRobot&gt; {\n      seeLoginButton()\n      clickLoginButton()\n    }\n  }\n}\n</code></pre> <code>AndroidViewRobot</code> <p><code>AndroidViewRobot</code> should be used as parent type when the robot interacts with Android Views. To obtain an instance of such a robot use the <code>robot&lt;Type&gt;()</code> function:</p> <pre><code>@ContributesRobot(AppScope::class)\nclass AndroidCounterRobot : AndroidViewRobot() {\n  fun seeCounterView() {\n    onView(withText(containsString(\"Counter: \"))).check(matches(isDisplayed()))\n  }\n}\n\n@Test\nfun counter_is_shown() {\n  robot&lt;AndroidCounterRobot&gt; {\n    seeCounterView()\n  }\n}\n</code></pre> <p><code>Robots</code> must be annotated with <code>@ContributesRobot</code> in order to find them during tests when using the <code>robot&lt;Type&gt;()</code> or <code>composeRobot&lt;Type&gt;()</code> function. The annotation makes sure that the robots are added to the <code>kotlin-inject-anvil</code> or Metro dependency graph.</p> Generated code <p>The <code>@ContributesRobot</code> annotation generates following code.</p> kotlin-inject-anvilMetro <pre><code>@ContributesTo(AppScope::class)\npublic interface LoginRobotComponent {\n  @Provides public fun provideLoginRobot(): LoginRobot = LoginRobot()\n\n  @Provides\n  @IntoMap\n  public fun provideLoginRobotIntoMap(\n    robot: () -&gt; LoginRobot\n  ): Pair&lt;KClass&lt;out Robot&gt;, () -&gt; Robot&gt; = LoginRobot::class to robot\n}\n</code></pre> <pre><code>@ContributesTo(AppScope::class)\npublic interface LoginRobotGraph {\n  @Provides public fun provideLoginRobot(): LoginRobot = LoginRobot()\n\n  @Provides\n  @IntoMap\n  @RobotKey(LoginRobot::class)\n  public fun provideLoginRobotIntoMap(\n    robot: Provider&lt;LoginRobot&gt;\n  ): Robot = robot()\n}\n</code></pre> <p>If a <code>Robot</code> needs to inject other types such a fake implementations, then it needs to be additionally annotated with <code>@Inject</code>, e.g.</p> <pre><code>@Inject\n@ContributesRobot(AppScope::class)\nclass MetricsRobot(\n  private val metricsService: FakeMetricsService\n) : Robot {\n  fun assertMetricTracked(metric: Metric) {\n    assertThat(metricsService.metrics).contains(metric)\n  }\n}\n</code></pre>"},{"location":"testing/#-robots-modules","title":"<code>:*-robots</code> modules","text":"<p>Similar to sharing fakes for unit tests by leveraging <code>:testing</code> modules, the module structure of App Platform provides <code>:*-robots</code> modules to share code for instrumented tests across projects. It\u2019s strongly encouraged for features to create <code>:*-robots</code> modules and share robot implementations.</p> Sample <p>The sample application comes with two robot implementations <code>LoginRobot</code> and <code>UserPageRobot</code>, each living in its feature specific <code>:robots</code> module.</p>"},{"location":"testing/#mocks","title":"Mocks","text":"<p>Which mocking framework is recommended?</p> <p>None.</p> <p>Mocking frameworks in general are discouraged and the downside outweigh the little conveniences they offer. By following the principle of dependency inversion we can easily avoid using mocking frameworks and implement fakes instead. There are many good resources available describing the advantages of fakes over mocking framework. We recommend reading the provided resources in-order:</p> <ul> <li>AndroidX strongly discourages mocking frameworks and banned them from new code. This guide explains in more detail their reasoning and it resonates well.</li> <li>Google engineers compare test doubles and give excellent advice for how to fake dependencies (this article is longer, but it\u2019s likely the best one available).</li> <li>developer.android.com prefers fakes over mocks for test doubles: \u201cFakes don\u2019t require a mocking framework and are lightweight. They are preferred.\u201d</li> <li>CashApp banned mocking frameworks in the Android codebase, because mocks are a maintenance burden.</li> <li>Ryan Harter calls out easy traps when using mocks.</li> <li>Pravin Sonawane makes similar arguments and highlights how mocks encourage testing the \u201chow\u201d rather than focusing on the \u201cwhat\u201d (inputs and outputs).</li> <li>Google blog Don\u2019t overuse mocks highlights some downsides of mocks and presents real or fake implementations as alternative.</li> </ul>"}]}